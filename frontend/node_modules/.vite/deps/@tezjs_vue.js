import {
  KeepAlive,
  createApp,
  defineAsyncComponent,
  defineComponent,
  h,
  shallowRef,
  unref
} from "./chunk-FDP2274Q.js";

// node_modules/@tezjs/js/dist/index.mjs
function isBot() {
  var botPattern = "(googlebot/|Googlebot-Mobile|rogerbot|dotbot|SemrushBot|MJ12bot|Googlebot-Image|Google favicon|Mediapartners-Google|bingbot|slurp|java|wget|curl|Commons-HttpClient|Python-urllib|libwww|httpunit|nutch|phpcrawl|msnbot|jyxobot|FAST-WebCrawler|FAST Enterprise Crawler|biglotron|teoma|convera|seekbot|gigablast|exabot|ngbot|ia_archiver|GingerCrawler|webmon |httrack|webcrawler|grub.org|UsineNouvelleCrawler|antibot|netresearchserver|speedy|fluffy|bibnum.bnf|findlink|msrbot|panscient|yacybot|AISearchBot|IOI|ips-agent|tagoobot|MJ12bot|dotbot|woriobot|yanga|buzzbot|mlbot|yandexbot|purebot|Linguee Bot|Voyager|CyberPatrol|voilabot|baiduspider|citeseerxbot|spbot|twengabot|postrank|turnitinbot|scribdbot|page2rss|sitebot|linkdex|Adidxbot|blekkobot|ezooms|dotbot|Mail.RU_Bot|discobot|heritrix|findthatfile|europarchive.org|NerdByNature.Bot|sistrix crawler|ahrefsbot|Aboundex|domaincrawler|wbsearchbot|summify|ccbot|edisterbot|seznambot|ec2linkfinder|gslfbot|aihitbot|intelium_bot|facebookexternalhit|yeti|RetrevoPageAnalyzer|lb-spider|sogou|lssbot|careerbot|wotbox|wocbot|ichiro|DuckDuckBot|lssrocketcrawler|drupact|webcompanycrawler|acoonbot|openindexspider|gnam gnam spider|web-archive-net.com.bot|backlinkcrawler|coccoc|integromedb|content crawler spider|toplistbot|seokicks-robot|it2media-domain-crawler|ip-web-crawler.com|siteexplorer.info|elisabot|proximic|changedetection|blexbot|arabot|WeSEE:Search|niki-bot|CrystalSemanticsBot|rogerbot|360Spider|psbot|InterfaxScanBot|Lipperhey SEO Service|CC Metadata Scaper|g00g1e.net|GrapeshotCrawler|urlappendbot|brainobot|fr-crawler|binlar|SimpleCrawler|Livelapbot|Twitterbot|cXensebot|smtbot|bnf.fr_bot|A6-Indexer|ADmantX|Facebot|Twitterbot|OrangeBot|memorybot|AdvBot|MegaIndex|SemanticScholarBot|ltx71|nerdybot|xovibot|BUbiNG|Qwantify|archive.org_bot|Applebot|TweetmemeBot|crawler4j|findxbot|SemrushBot|yoozBot|lipperhey|y!j-asr|Domain Re-Animator Bot|AddThis|SemrushBot-SA|Screaming Frog SEO Spider)";
  var re = new RegExp(botPattern, "i");
  if (typeof navigator === "undefined")
    return false;
  return re.test(navigator.userAgent);
}
var callback = function(cb) {
  const start = Date.now();
  return setTimeout(function() {
    cb({
      didTimeout: false,
      timeRemaining: () => Math.max(0, 50 - (Date.now() - start))
    });
  }, 1);
};
var idleCallback = typeof window !== "undefined" ? window.requestIdleCallback || callback : callback;
function isMobile() {
  let check = false;
  if (typeof navigator !== "undefined")
    (function(a) {
      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|Ipad|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
        check = true;
    })(navigator.userAgent || navigator.vendor);
  return check;
}
function run(eventName) {
  let called = false;
  const process = (event) => {
    if (!called) {
      called = true;
      document.removeEventListener(eventName, process);
      jsContainer.config.afterInteration.funcs.forEach((func) => func());
    }
  };
  return process;
}
function subscribe() {
  return () => {
    let eventName = isMobile() ? "touchstart" : "mouseover";
    document.addEventListener(eventName, run(eventName), { passive: true });
  };
}
function afterUserInteraction$1() {
  if (!isBot())
    idleCallback(subscribe(), { timeout: 2e3 });
}
var jsContainer = new class {
  constructor() {
    this.config = { afterInteration: { eventSubscribed: false, funcs: new Array() } };
  }
  addAfterInteration(funcs) {
    if (funcs.length > 0 && !this.config.afterInteration.eventSubscribed) {
      this.config.afterInteration.eventSubscribed = true;
      afterUserInteraction$1();
    }
    funcs.forEach((func) => this.config.afterInteration.funcs.push(func));
  }
}();
function afterUserInteraction(afterUserInteraction2) {
  jsContainer.addAfterInteration(afterUserInteraction2);
}

// node_modules/hookable/dist/index.mjs
function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
function serialCaller(hooks, args) {
  return hooks.reduce((promise, hookFn) => promise.then(() => hookFn.apply(void 0, args)), Promise.resolve(null));
}
function parallelCaller(hooks, args) {
  return Promise.all(hooks.map((hook) => hook.apply(void 0, args)));
}
var Hookable = class {
  constructor() {
    this._hooks = {};
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, fn) {
    if (!name || typeof fn !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let deprecatedHookObj;
    while (this._deprecatedHooks[name]) {
      const deprecatedHook = this._deprecatedHooks[name];
      if (typeof deprecatedHook === "string") {
        deprecatedHookObj = { to: deprecatedHook };
      } else {
        deprecatedHookObj = deprecatedHook;
      }
      name = deprecatedHookObj.to;
    }
    if (deprecatedHookObj) {
      if (!deprecatedHookObj.message) {
        console.warn(`${originalName} hook has been deprecated` + (deprecatedHookObj.to ? `, please use ${deprecatedHookObj.to}` : ""));
      } else {
        console.warn(deprecatedHookObj.message);
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(fn);
    return () => {
      if (fn) {
        this.removeHook(name, fn);
        fn = null;
      }
    };
  }
  hookOnce(name, fn) {
    let _unreg;
    let _fn = (...args) => {
      _unreg();
      _unreg = null;
      _fn = null;
      return fn(...args);
    };
    _unreg = this.hook(name, _fn);
    return _unreg;
  }
  removeHook(name, fn) {
    if (this._hooks[name]) {
      const idx = this._hooks[name].indexOf(fn);
      if (idx !== -1) {
        this._hooks[name].splice(idx, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = deprecated;
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map((key) => this.hook(key, hooks[key]));
    return () => {
      removeFns.splice(0, removeFns.length).forEach((unreg) => unreg());
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  callHook(name, ...args) {
    return serialCaller(this._hooks[name] || [], args);
  }
  callHookParallel(name, ...args) {
    return parallelCaller(this._hooks[name] || [], args);
  }
  callHookWith(caller, name, ...args) {
    return caller(this._hooks[name] || [], args);
  }
};
function createHooks() {
  return new Hookable();
}

// node_modules/@tezjs/vue/dist/index.mjs
var activePageState = new class {
  constructor() {
    this.page = { url: "", layoutName: "", masterPageSlots: {}, slots: {} };
    this.hooks = createHooks();
  }
  setActivePage(pageState) {
    this.page.slots = pageState.slots;
    this.page.masterPageSlots = pageState.masterPageSlots;
    this.page.layoutName = pageState.layoutName;
    this.page.url = pageState.url;
    this.page.layoutComponent = pageState.layoutComponent;
    this.page.postScript = pageState.postScript;
    this.hooks.callHook("tez:activePageChanged", this.page);
    this.hooks.callHook("tez:layoutNameChanged", this.page.layoutName);
    this.hooks.callHook("tez:slotsChanged", { slots: this.page.slots, masterPageSlots: this.page.masterPageSlots });
    this.hooks.callHook("tez:layoutComponentChanged", { component: this.page.layoutComponent });
  }
  updateActivePageSlots() {
    this.hooks.callHook("tez:slotsUpdated", { slots: this.page.slots });
  }
}();
function setMetaInfo(metaInfo) {
  var metas = document.querySelectorAll("meta[data-head='tezjs']");
  metas.forEach((x) => x.remove());
  var title = document.getElementsByTagName("title")[0];
  var canonical = document.querySelector('link[rel="canonical"');
  var ldJson = document.querySelector('script[type="application/ld+json"');
  if (ldJson)
    ldJson.remove();
  if (title)
    title.innerText = metaInfo.title;
  else {
    title = document.createElement("title");
    title.innerText = metaInfo.title;
    document.head.insertBefore(title, document.head.firstChild);
  }
  if (canonical) {
    canonical.rel = "canonical";
    canonical.setAttribute("data-head", "tezjs");
    canonical.href = metaInfo.canonical;
  } else {
    canonical = document.createElement("link");
    canonical.setAttribute("data-head", "tezjs");
    canonical.rel = "canonical";
    canonical.href = metaInfo.canonical;
    document.head.insertBefore(canonical, document.head.firstChild);
  }
  if (metaInfo.metaTag)
    addMetas(metaInfo.metaTag, canonical);
  if (metaInfo.linkingData)
    addPageSchema(metaInfo.linkingData, canonical);
}
function addMetas(metaTag, insertBeforeElement) {
  ["name", "property"].forEach((propName) => {
    if (metaTag[propName])
      Object.keys(metaTag[propName]).forEach((key) => addMeta(propName, key, metaTag[propName][key], insertBeforeElement));
  });
}
function addMeta(type, key, value, insertBeforeElement) {
  var metaElement = document.createElement("meta");
  metaElement.setAttribute("data-head", "tezjs");
  const typeSetterProp = type === "name" ? "name" : "title";
  if (type !== "charset") {
    metaElement[typeSetterProp] = key;
    metaElement.content = value;
  } else
    metaElement.setAttribute(type, value);
  document.head.insertBefore(metaElement, insertBeforeElement);
}
function addPageSchema(linkingData, insertBeforeElement) {
  linkingData.split("--").forEach((data) => {
    let scriptElement = document.createElement("script");
    scriptElement.setAttribute("data-head", "tezjs");
    scriptElement.type = "application/ld+json";
    scriptElement.textContent = data.trim();
    document.head.insertBefore(scriptElement, insertBeforeElement);
  });
}
function getCurrentUrl() {
  return window.location.pathname;
}
function subStringText(url) {
  if (url && url.length > 1 && url.substr(url.length - 1, url.length) === "/")
    url = url.substr(0, url.length - 1);
  return url;
}
function getUrl$1(url) {
  return url === "/" ? "/index" : url === "/index" ? "/" : subStringText(url);
}
function getUrl(baseUrl) {
  const url = baseUrl || getCurrentUrl();
  return getUrl$1(url);
}
function isTitleElementExist() {
  return document.getElementsByTagName("title")[0] !== void 0;
}
var tezPages = new class {
  constructor() {
    this.components = {};
    this.masterPages = {};
    this.pages = {};
    this.urlReference = {};
    this.isInitializationMode = true;
  }
  setComponents(components) {
    Object.keys(components).forEach((key) => {
      if (!this.components[key])
        this.components[key] = components[key];
    });
  }
  setMasterPage(masterPage) {
    if (masterPage)
      Object.keys(masterPage).forEach((key) => {
        if (!this.masterPages[key])
          this.masterPages[key] = masterPage[key];
      });
  }
  setUrlReference(url, referenceStateUrl) {
    this.urlReference[url] = referenceStateUrl;
  }
  getUrlReference(url) {
    return this.urlReference[url];
  }
  setPage(page) {
    if (page.payload) {
      let url = page.payload.url || getUrl();
      if (!this.pages[url])
        this.pages[url] = { ...page.payload, ...{ postScript: page.postScript } };
      else {
        Object.keys(page.payload.slots).forEach((slotName) => {
          if (!this.pages[url].slots[slotName])
            this.pages[url].slots[slotName] = [];
          if (this.pages[url].slots && this.pages[url].slots[slotName])
            page.payload.slots[slotName].forEach((item) => {
              let component = this.pages[url].slots[slotName].filter((t) => t.id === item.id)[0];
              if (component)
                component.data = item.data;
            });
        });
      }
      if (this.isInitializationMode) {
        this.isInitializationMode = false;
        this.refreshRoute(url);
      }
    }
    if (!isTitleElementExist() && page.payload && page.payload.isPage && page.payload.tags)
      setMetaInfo(page.payload.tags);
  }
  refreshRoute(url) {
    let urlReference = this.getUrlReference(url) || url;
    let currentPage = this.pages[urlReference];
    activePageState.setActivePage({
      layoutName: currentPage.layoutName,
      slots: currentPage.slots,
      masterPageSlots: currentPage.masterPageSlots,
      url: currentPage.url,
      postScript: currentPage.postScript
    });
  }
  getPayload(to) {
    let url = to || getUrl();
    return this.pages[url];
  }
  isExits(url) {
    let requestedUrl = getUrl(url);
    return this.pages[requestedUrl] !== void 0;
  }
  registerPage(page) {
    this.setComponents(page.components);
    this.setMasterPage(page.masterPage);
    this.setPage(page);
  }
}();
function getCurrentScrollPosition() {
  return {
    left: window.pageXOffset,
    top: window.pageYOffset
  };
}
var assign = Object.assign;
var Router = class {
  constructor() {
    this.historyState = { value: history.state };
    this.url = getCurrentUrl();
    this.currentUrl = this.url;
    const { pathname, search, hash } = location;
    this.url = pathname + search + hash;
    if (!this.historyState.value)
      this.changeRoute(this.url, {
        back: null,
        current: this.url,
        forward: null,
        position: history.length - 1,
        replaced: true,
        scroll: null
      }, true);
    window.addEventListener("popstate", ({ state }) => {
      this.historyState.value = state;
      this.changeRouteState(state && state.current ? state.current : getCurrentUrl(), true).then((t) => {
        const hash2 = location.hash;
        if (hash2) {
          let element = document.getElementById(hash2.replace("#", ""));
          if (element)
            element.scrollIntoView();
        }
      });
    });
  }
  push(to) {
    if (typeof to === "string")
      this.changeRouteState(to);
    else if (to.path) {
      this.routeOptions = to;
      this.changeRouteState(to.path);
    }
  }
  changeRouteState(to, isPopState = false) {
    this.changeScrollPosition();
    return this.resolve(to).then((t) => {
      this.refreshPageMetaTags(to);
      if (!isPopState) {
        const currentState = assign({}, this.historyState.value, history.state, {
          forward: to,
          scroll: getCurrentScrollPosition()
        });
        this.changeRoute(currentState.current, currentState, true);
        const state = assign({}, this.createState({ back: this.currentUrl, current: to, forward: null }), { position: currentState.position + 1 });
        this.changeRoute(to, state, false);
        this.routeOptions = void 0;
      }
      this.currentUrl = to;
      tezPages.refreshRoute(to);
    });
  }
  resolve(url) {
    return resolveRoute(url);
  }
  refreshPageMetaTags(to) {
    let payload = tezPages.getPayload(to);
    if (payload && payload.tags)
      setMetaInfo(payload.tags);
  }
  changeRoute(url, state, replace) {
    history[replace ? "replaceState" : "pushState"](state, "", !replace ? this.getFullUrl(url) : url);
    this.historyState.value = state;
  }
  getFullUrl(url) {
    let queryParams = "";
    if (this.routeOptions && this.routeOptions.query) {
      queryParams = "?";
      Object.keys(this.routeOptions.query).forEach((key) => {
        queryParams += `${key}=${this.routeOptions.query[key]}`;
      });
    }
    return `${url}${queryParams}`;
  }
  changeScrollPosition() {
    if ("scrollBehavior" in document.documentElement.style)
      window.scrollTo({
        behavior: "smooth",
        top: 0
      });
    else {
      window.scrollTo(window.pageXOffset, 0);
    }
  }
  createState(state) {
    return {
      back: state.back,
      current: state.current,
      forward: state.forward,
      replaced: state.replaced,
      position: window.history.length,
      scroll: getCurrentScrollPosition()
    };
  }
};
var componentState = new class {
  constructor() {
    this.tezAppOptions = void 0;
    this.currentRoute = shallowRef({ params: {} });
  }
  defineGlobalProps(app) {
    app.config.globalProperties.$tezRouter = new Router();
    Object.defineProperty(app.config.globalProperties, "$tezRoute", {
      enumerable: true,
      get: () => unref(this.currentRoute)
    });
  }
  changeRouteValue(routeValue) {
    this.currentRoute.value = routeValue;
  }
}();
var urlMatch = (urlPatten, url) => {
  const RIGHT_SLASH = "/";
  const splitUPattern = urlPatten.split(RIGHT_SLASH);
  const splitUrl = url.split(RIGHT_SLASH);
  let isMatched = splitUPattern.length === splitUrl.length;
  let params = {};
  if (isMatched)
    for (let i = 0; i < splitUPattern.length; i++) {
      if (/:/.test(splitUPattern[i])) {
        params[splitUPattern[i].replace(":", "")] = splitUrl[i];
        isMatched = true;
      } else
        isMatched = splitUPattern[i].toLowerCase() === splitUrl[i].toLowerCase();
      if (!isMatched)
        break;
    }
  return isMatched ? { params } : isMatched;
};
function checkAutoRoute(path) {
  let route = {};
  if (componentState.tezAppOptions.dynamicRoutes) {
    {
      const urlPattern = Object.keys(componentState.tezAppOptions.dynamicRoutes);
      for (const url of urlPattern) {
        const match = urlMatch(url, path);
        if (match) {
          route.resolvePath = componentState.tezAppOptions.dynamicRoutes[url];
          route.params = match.params;
          break;
        }
      }
    }
  }
  return route;
}
function getVersion() {
  return window.localStorage.getItem("tzV");
}
function getPreloadScriptUrl(url) {
  return componentState.tezAppOptions.isDevMode ? `/tez/deps${url}/preload.js?v=${getVersion()}` : `${url}/preload.${componentState.tezAppOptions.buildVersion}.js`;
}
function getPreScriptUrl(url) {
  return componentState.tezAppOptions.isDevMode ? `/tez/deps${url}/pre.js?v=${getVersion()}` : `${url}/pre.${componentState.tezAppOptions.buildVersion}.js`;
}
function getDynamicRouteScriptUrl() {
  return componentState.tezAppOptions.isDevMode ? `/tez/deps/dynamic-routes.js?v=${getVersion()}` : `/assets/dynamic-routes.${componentState.tezAppOptions.buildVersion}.js`;
}
var seen = /* @__PURE__ */ new Set();
function preloadDependencies(baseModule, deps) {
  const base = "/";
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = `${base}${dep}`;
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : "modulepreload";
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", rej);
      });
    }
  })).then(() => baseModule());
}
function registerDynamicRoutes(routes) {
  componentState.tezAppOptions.dynamicRoutes = routes;
}
function registerTezPage(page) {
  tezPages.registerPage(page);
}
var WINDOW_TEZ_DATA = "TEZ_DATA";
function registerData(resolve) {
  return (func) => {
    func(registerTezPage, preloadDependencies);
    resolve(true);
  };
}
async function resolveRoute(url) {
  return resolvePreloadCode(componentState.tezAppOptions, url);
}
async function resolvePreloadCode(tezAppOptions, to) {
  return new Promise((resolve, reject) => {
    let url = getUrl(to);
    if (!tezPages.isExits(url)) {
      import(
        /* @vite-ignore */
        getPreloadScriptUrl(url)
      ).then((t) => t.default).then((t) => {
        t(preloadDependencies).then((t2) => t2.default).then(registerData(resolve));
      }).catch(failedRoute(url, resolve));
    } else
      resolve(true);
  });
}
async function resolvePreCode(tezAppOptions, to) {
  return new Promise((resolve, reject) => {
    let url = getUrl(to);
    if (window[WINDOW_TEZ_DATA]) {
      registerData(resolve)(window[WINDOW_TEZ_DATA]);
      delete window[WINDOW_TEZ_DATA];
      return;
    }
    if (!tezPages.isExits(url)) {
      import(
        /* @vite-ignore */
        getPreScriptUrl(url)
      ).then((t) => t.default).then(registerData(resolve)).catch(failedRoute(url, resolve));
    } else
      resolve(true);
  });
}
function resolveDynamicRoute() {
  return new Promise((resolve, reject) => {
    if (!componentState.tezAppOptions.dynamicRoutes) {
      import(
        /* @vite-ignore */
        getDynamicRouteScriptUrl()
      ).then((t) => t.default).then((func) => {
        func(registerDynamicRoutes);
        resolve(true);
      });
    } else
      resolve(true);
  });
}
function failedRoute(url, resolve) {
  return (reason) => {
    resolveDynamicRoute().then((isSet) => {
      let dynamicRoutes = componentState.tezAppOptions.dynamicRoutes;
      if (dynamicRoutes && Object.keys(dynamicRoutes).length > 0) {
        let route = checkAutoRoute(url);
        if (route.resolvePath) {
          resolvePreloadCode(componentState.tezAppOptions, route.resolvePath).then((t) => {
            componentState.changeRouteValue({ params: route.params });
            tezPages.setUrlReference(url, route.resolvePath);
            resolve(true);
          });
        }
      }
    });
  };
}
var cacheState = new class {
  constructor() {
    this.layoutVNode = {};
    this.pageVnodes = {};
    this.cachedRoute = {};
    this.routes = {};
    this.cachedRouteCount = 0;
  }
  addRoute(route) {
    var _a, _b;
    const clientConfig = componentState.tezAppOptions.clientConfig;
    if ((_a = clientConfig == null ? void 0 : clientConfig.preCache) == null ? void 0 : _a.route) {
      const routeConfig = (_b = clientConfig == null ? void 0 : clientConfig.preCache) == null ? void 0 : _b.route;
      route = route.toLowerCase();
      const isCache = routeConfig === true || routeConfig.test(route);
      if (!this.cachedRoute[route] && !this.routes[route] && isCache) {
        this.routes[route] = true;
        if (this.cachedRouteCount > 0)
          idleCallback(() => this.preCacheRoutes(route), { timeout: 10 });
      }
    }
  }
  preCacheRoutes(routePath) {
    const routes = routePath ? [routePath] : Object.keys(this.routes);
    for (const route of routes) {
      delete this.routes[route];
      resolveRoute(route);
      this.cachedRoute[route] = true;
      this.cachedRouteCount++;
    }
  }
  cacheVNode(id, vNode) {
    let url = getUrl();
    if (!this.pageVnodes[url])
      this.pageVnodes[url] = {};
    this.pageVnodes[url][id] = vNode;
    return vNode;
  }
  getVNode(id) {
    let url = getUrl();
    if (!this.pageVnodes[url])
      return;
    return this.pageVnodes[url][id];
  }
}();
var isExecuted = false;
function runAddLib() {
  if (!isExecuted) {
    isExecuted = true;
    setTimeout(() => {
      if (componentState.tezAppOptions.libConfig) {
        const libConfig = componentState.tezAppOptions.libConfig;
        if (libConfig.runOn) {
          let idleTime = libConfig.runOn.idleTime;
          for (let idleTimeFunc of idleTime) {
            idleTimeFunc();
          }
        }
        if (libConfig.afterUserInteraction)
          afterUserInteraction(libConfig.afterUserInteraction);
      }
      cacheState.preCacheRoutes();
    }, 2500);
  }
}
var TezSlot = defineComponent({
  data() {
    return {
      scrollFunction: null,
      isScrolled: false,
      postScript: null,
      previousState: null,
      isInView: false,
      lazyRef: null,
      observer: null,
      slots: {},
      masterPageSlots: {},
      components: new Array(),
      nextIndex: 0
    };
  },
  props: {
    slotName: { type: String, default: "default" },
    slotCategory: { type: String, default: "page" },
    preserveComponentState: { type: Boolean }
  },
  async mounted() {
    this.slots = activePageState.page.slots;
    this.masterPageSlots = activePageState.page.masterPageSlots;
    this.postScript = activePageState.page.postScript;
    if (this.slotCategory !== "master") {
      if (!isBot())
        this.subscribeScroll();
      activePageState.hooks.hook("tez:activePageChanged", (pageState) => {
        this.slots = pageState.slots;
        this.masterPageSlots = pageState.masterPageSlots;
        this.postScript = pageState.postScript;
        this.components = new Array();
        this.nextIndex = 0;
        this.goToNextComponent(true);
      });
    }
    this.goToNextComponent(true);
  },
  methods: {
    subscribeScroll() {
      this.scrollFunction = this.onScroll.bind(this);
      window.addEventListener("scroll", this.scrollFunction);
    },
    async onScroll() {
      if (!this.isScrolled) {
        this.isScrolled = true;
        window.removeEventListener("scroll", this.scrollFunction);
        await this.loadPostScript();
        this.isInView = true;
        this.goToNextComponent();
      }
    },
    getSlotComponents(slotName, slotCategory) {
      if (slotCategory === "master") {
        return this.masterPageSlots[slotName] ? this.masterPageSlots[slotName] : [];
      }
      return this.slots[slotName] ? this.slots[slotName] : [];
    },
    subscribeLazy() {
      if (this.$refs.divLazy) {
        let isContinue = false;
        this.observer = new IntersectionObserver(async ([{ isIntersecting }]) => {
          this.isInView = isIntersecting;
          if (isIntersecting && this.previousState !== isIntersecting) {
            if (this.nextIndex == this.getMaxPreComponentCount() && this.postScript)
              await this.loadPostScript();
            this.goToNextComponent(isContinue);
          }
          this.previousState = isIntersecting;
          isContinue = true;
        });
        this.observer.observe(this.$refs.divLazy);
      }
    },
    getMaxPreComponentCount() {
      return componentState.tezAppOptions.maxPreComponentCount;
    },
    async goToNextComponent(isContinue) {
      if (isContinue === false)
        return;
      if (!this.observer && !isBot()) {
        this.subscribeLazy();
        this.isInView = isContinue;
        if (!this.isInView)
          return;
      }
      this.isInView = isContinue || isBot() || this.isInView;
      if (this.isInView) {
        let components = this.getSlotComponents(this.slotName, this.slotCategory);
        let _components = [];
        if (this.nextIndex == this.getMaxPreComponentCount() && this.postScript || this.postScript && isBot())
          await this.loadPostScript();
        if (components.length > this.nextIndex && !this.components[this.nextIndex]) {
          let increCount = isBot() ? components.length : this.nextIndex == this.getMaxPreComponentCount() + 1 ? components.length : this.nextIndex + 1;
          let startIndex = this.nextIndex;
          for (var i = startIndex; i < increCount; i++) {
            let componentItem = components[this.nextIndex];
            let componentName = this.getComponentName(componentItem);
            if (tezPages.components[componentName]) {
              _components.push(componentItem);
              this.nextIndex++;
              if (increCount !== components.length)
                idleCallback(() => this.goToNextComponent(), { timeout: 0 });
            }
          }
          _components.forEach((component) => this.components.push(component));
          if (this.slotCategory === "page" && components.length === this.components.length && components.length === 1)
            runAddLib();
        }
      } else if (this.slotCategory === "page")
        runAddLib();
    },
    loadPostScript() {
      if (this.postScript)
        return this.postScript().then((postScript) => {
          postScript.default(registerTezPage);
          this.postScript = null;
        });
    },
    getComponentName(component) {
      return isMobile() && component.mobileComponentName ? component.mobileComponentName : component.name;
    }
  },
  render() {
    let vNodes = new Array();
    for (let component of this.components) {
      let componentName = this.getComponentName(component);
      let vNode = cacheState.getVNode(component.id);
      if (!vNode)
        vNode = cacheState.cacheVNode(component.id, h(tezPages.components[componentName], { data: component.data }));
      vNodes.push(h(KeepAlive, { key: `${getCurrentUrl()}${component.itemName}` }, vNode));
    }
    if (!this.lazyRef)
      this.lazyRef = h("div", { ref: "divLazy", style: { "height": "2px" } }, "");
    vNodes.push(this.lazyRef);
    return h("div", vNodes);
  }
});
var TezIndex = defineComponent({
  render() {
    return h(TezSlot);
  }
});
function getPayloadPath(url) {
  return `/payload${url}`;
}
async function getJsonPayload(name, refUrl) {
  const url = getUrl(refUrl);
  const fileName = name ? name : url.split("/").pop();
  const response = await fetch(getPayloadPath(`${url}/${fileName}.json`));
  const data = await response.json();
  return data;
}
var TezLazy = defineComponent({
  data() {
    return {
      items: [],
      lazyRef: null,
      observer: null,
      index: 0,
      lastItem: null
    };
  },
  props: ["sourcePath", "currentPage", "class"],
  watch: {
    currentPage(value) {
      if (this.index != value) {
        this.index = value;
        this.loadJson();
      }
    }
  },
  mounted() {
    this.subscribeLazy();
  },
  methods: {
    subscribeLazy() {
      if (this.$refs.divLazy) {
        this.observer = new IntersectionObserver(async ([{ isIntersecting }]) => {
          if (isIntersecting) {
            this.index++;
            this.loadJson();
          }
        });
        this.observer.observe(this.$refs.divLazy);
      }
    },
    async loadJson() {
      if (this.sourcePath && (!this.lastItem || this.lastItem.totalCount > this.index * this.lastItem.items.length)) {
        let source = await getJsonPayload(String(this.index), `/${this.sourcePath}`);
        source.items.forEach((t) => {
          this.items.push(t);
        });
        this.lastItem = source;
      } else if (this.observer)
        this.observer.unobserve(this.$refs.divLazy);
    }
  },
  render() {
    var _a;
    let vNodes = new Array();
    if (this.$slots && this.$slots.default && this.items && this.items.length > 0)
      vNodes.push(h("div", { class: this.class }, (_a = this.$slots) == null ? void 0 : _a.default({
        items: this.items
      })));
    if (!this.lazyRef)
      this.lazyRef = h("div", { ref: "divLazy" }, "");
    vNodes.push(this.lazyRef);
    return h("div", vNodes);
  }
});
var TezPage = defineComponent({
  data() {
    return {
      vNode: h("div")
    };
  },
  render() {
    this.vNode = h(TezSlot);
    return h(h(KeepAlive, null, this.vNode));
  }
});
var TAG = "a";
function isPush(event) {
  if (event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    return;
  if (event.defaultPrevented)
    return;
  if (event.button !== void 0 && event.button !== 0)
    return;
  if (event.currentTarget && event.currentTarget.getAttribute) {
    const target = event.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (event.preventDefault)
    event.preventDefault();
  return true;
}
var TezLink = defineComponent({
  props: ["to", "class"],
  mounted() {
    cacheState.addRoute(this.to);
  },
  render() {
    let children = this.$slots.default ? this.$slots.default() : void 0;
    return h(TAG, {
      onClick: (e) => {
        if (isPush(e))
          this.$tezRouter.push(this.to);
      },
      href: this.to,
      class: this.class
    }, children);
  }
});
function getScreenSize() {
  if (typeof window !== "undefined")
    return screen.width;
  return 0;
}
var NODE_NAME = "div";
var TezIterator = defineComponent({
  data() {
    return {
      sourceItems: [],
      isInteractive: false,
      observer: null,
      lazyRef: null,
      lastIndex: 0,
      defaultCount: 10
    };
  },
  props: ["items", "class", "childClass", "countSM", "countMD", "countLG", "countXL", "vNode", "vChildNode"],
  computed: {
    pickCount: {
      get() {
        let count = this.defaultCount;
        const screenSize = getScreenSize();
        if (screenSize >= 1200)
          count = this.countXL || this.defaultCount;
        else if (screenSize >= 992)
          count = this.countLG || this.defaultCount;
        else if (screenSize >= 768)
          count = this.countMD || this.defaultCount;
        else
          count = this.countSM || this.defaultCount;
        return parseInt(count);
      },
      set(v) {
      }
    }
  },
  watch: {
    items: function(value) {
      this.bindNext();
    }
  },
  mounted() {
    this.subscribeLazy();
  },
  methods: {
    subscribeLazy() {
      if (this.$refs.divLazy) {
        this.observer = new IntersectionObserver(async ([{ isIntersecting }]) => {
          this.isInteractive = isIntersecting;
          if (isIntersecting)
            this.bindNext();
        });
        this.observer.observe(this.$refs.divLazy);
      }
    },
    bindNext() {
      if (this.isInteractive) {
        if (this.sourceItems.length <= this.items.length) {
          let length = this.items.length;
          let pickCount = this.pickCount;
          length = this.items.length > this.lastIndex + pickCount ? this.lastIndex + pickCount : this.lastIndex + (this.items.length - this.sourceItems.length);
          for (var i = this.lastIndex; i < length; i++) {
            let item = this.items[i];
            this.sourceItems.push(item);
          }
          this.lastIndex = length;
        }
      }
    }
  },
  render() {
    let vNodes = new Array();
    if (this.$slots && this.$slots.default)
      this.sourceItems.forEach((item, index) => {
        let slot = this.$slots && this.$slots.default ? this.$slots.default({ ...item }) : [];
        vNodes.push(h(this.vChildNode || NODE_NAME, { class: this.childClass, key: index }, slot));
      });
    if (this.sourceItems.length > 0)
      idleCallback(this.bindNext, { timeout: 2e3 });
    if (!this.lazyRef)
      this.lazyRef = h("div", { ref: "divLazy" }, "");
    vNodes.push(this.lazyRef);
    return h(this.vNode || NODE_NAME, { class: this.class }, vNodes);
  }
});
var TzTickedMixin = {
  mounted: function() {
    const _this = this;
    _this.$nextTick(function() {
      var _a, _b, _c;
      if ((_c = (_b = (_a = _this.$parent) == null ? void 0 : _a.$parent) == null ? void 0 : _b.$parent) == null ? void 0 : _c.tzTicked)
        setTimeout(() => {
          _this.$parent.$parent.$parent.tzTicked();
        }, 10);
    });
  }
};
var imageLoader = new class {
  constructor() {
    this.cachedImage = {};
    this.resolveRequest = {};
    this.imageRequestBroadcaster = void 0;
  }
  register() {
    if (window.location.hostname.indexOf("localhost") === -1) {
      this.imageRequestBroadcaster = new Worker(`/tz.${componentState.tezAppOptions.buildVersion}.js`);
      this.imageRequestBroadcaster.onmessage = (event) => {
        if (this.resolveRequest[event.data.url]) {
          this.cachedImage[event.data.url] = event.data.baseString;
          this.resolveRequest[event.data.url].forEach((resolve) => resolve(event.data.baseString));
          delete this.resolveRequest[event.data.url];
        }
      };
    }
  }
  getImage(url) {
    return this.cachedImage[url];
  }
  resolve(url) {
    return new Promise((resolve, reject) => {
      if (!this.cachedImage[url]) {
        if (!this.resolveRequest[url])
          this.resolveRequest[url] = [resolve];
        else
          this.resolveRequest[url].push(resolve);
        this.imageRequestBroadcaster.postMessage({
          url
        });
      } else
        resolve(this.cachedImage[url]);
    });
  }
}();
var TEZ_SRC_DIRECTIVE = {
  beforeMount: function(el, binding, vnode, prevVnode) {
    if (!isBot()) {
      const cachedImage = imageLoader.getImage(binding.value);
      if (cachedImage) {
        el.src = cachedImage;
        return;
      }
      if (componentState.tezAppOptions.loaderImagePath)
        el.src = componentState.tezAppOptions.loaderImagePath;
      let observer = new IntersectionObserver(function(entries) {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (window.location.hostname.indexOf("localhost") === -1)
              imageLoader.resolve(binding.value).then((image) => el.src = image);
            else
              el.src = binding.value;
            observer.unobserve(el);
          }
        });
      }, { threshold: [0.25] });
      observer.observe(el);
      el.observer = observer;
    } else
      el.src = binding.value;
  }
};
var tez = new class {
  register(tezAppOptions) {
    return {
      install(Vue) {
        if (tezAppOptions.useVue)
          tezAppOptions.useVue(Vue);
        componentState.defineGlobalProps(Vue);
        Vue.component("TezIndex", TezIndex);
        Vue.component("TezSlot", TezSlot);
        Vue.component("TezLazy", TezLazy);
        Vue.component("TezPage", TezPage);
        Vue.component("TezLink", TezLink);
        Vue.component("TezIterator", TezIterator);
        Vue.directive("tez-src", TEZ_SRC_DIRECTIVE);
        Vue.mixin(TzTickedMixin);
      }
    };
  }
}();
var CACHE_KEY_LAYOUT_TEZ_PAGE = "layout_tezpage";
var TezView = defineComponent({
  data() {
    return {
      state: {},
      tezNode: h(TezIndex),
      vNode: void 0,
      layoutName: void 0,
      layoutComponent: void 0
    };
  },
  mounted() {
    this.layoutName = activePageState.page.layoutName;
    this.layoutComponent = activePageState.page.layoutComponent;
    this.subscribeHooks();
  },
  methods: {
    subscribeHooks() {
      activePageState.hooks.hook("tez:layoutNameChanged", (layoutName) => {
        this.layoutName = layoutName;
      });
      activePageState.hooks.hook("tez:layoutComponentChanged", (component) => {
        this.layoutComponent = component;
      });
    }
  },
  render() {
    let vNode = void 0;
    let layoutComponent = tezPages.masterPages[this.layoutName];
    if (typeof layoutComponent === "function")
      tezPages.masterPages[this.layoutName] = layoutComponent = defineAsyncComponent(layoutComponent);
    if (!layoutComponent)
      cacheState.layoutVNode[CACHE_KEY_LAYOUT_TEZ_PAGE] = vNode = cacheState.layoutVNode[CACHE_KEY_LAYOUT_TEZ_PAGE] || h(TezPage);
    else if (layoutComponent)
      cacheState.layoutVNode[this.layoutName] = vNode = cacheState.layoutVNode[this.layoutName] || h(layoutComponent);
    return h(h(KeepAlive, null, vNode));
  }
});
function createTezApp(tezAppOptions) {
  componentState.tezAppOptions = tezAppOptions;
  imageLoader.register();
  resolvePreCode().then((t) => createApp(TezView).use(tez.register(tezAppOptions)).mount("#tez_app"));
}
function addPreCacheAssets() {
  let message = getMessage();
  if (message)
    navigator.serviceWorker.getRegistration().then((registration) => {
      if ("active" in registration && navigator.onLine) {
        registration.active.postMessage(message);
      }
    });
}
function getMessage() {
  return window["TEZ_PRE_CACHE_ASSETS"];
}
export {
  addPreCacheAssets,
  createTezApp,
  imageLoader,
  registerTezPage
};
//# sourceMappingURL=@tezjs_vue.js.map
