import { shallowRef, unref, defineComponent, h, KeepAlive, defineAsyncComponent, createApp } from 'vue';
import { idleCallback, afterUserInteraction, isBot, isMobile } from '@tezjs/js';
import { createHooks } from 'hookable';

const activePageState = new class {
  constructor() {
    this.page = { url: "", layoutName: "", masterPageSlots: {}, slots: {} };
    this.hooks = createHooks();
  }
  setActivePage(pageState) {
    this.page.slots = pageState.slots;
    this.page.masterPageSlots = pageState.masterPageSlots;
    this.page.layoutName = pageState.layoutName;
    this.page.url = pageState.url;
    this.page.layoutComponent = pageState.layoutComponent;
    this.page.postScript = pageState.postScript;
    this.hooks.callHook("tez:activePageChanged", this.page);
    this.hooks.callHook("tez:layoutNameChanged", this.page.layoutName);
    this.hooks.callHook("tez:slotsChanged", { slots: this.page.slots, masterPageSlots: this.page.masterPageSlots });
    this.hooks.callHook("tez:layoutComponentChanged", { component: this.page.layoutComponent });
  }
  updateActivePageSlots() {
    this.hooks.callHook("tez:slotsUpdated", { slots: this.page.slots });
  }
}();

function setMetaInfo(metaInfo) {
  var metas = document.querySelectorAll("meta[data-head='tezjs']");
  metas.forEach((x) => x.remove());
  var title = document.getElementsByTagName("title")[0];
  var canonical = document.querySelector('link[rel="canonical"');
  var ldJson = document.querySelector('script[type="application/ld+json"');
  if (ldJson)
    ldJson.remove();
  if (title)
    title.innerText = metaInfo.title;
  else {
    title = document.createElement("title");
    title.innerText = metaInfo.title;
    document.head.insertBefore(title, document.head.firstChild);
  }
  if (canonical) {
    canonical.rel = "canonical";
    canonical.setAttribute("data-head", "tezjs");
    canonical.href = metaInfo.canonical;
  } else {
    canonical = document.createElement("link");
    canonical.setAttribute("data-head", "tezjs");
    canonical.rel = "canonical";
    canonical.href = metaInfo.canonical;
    document.head.insertBefore(canonical, document.head.firstChild);
  }
  if (metaInfo.metaTag)
    addMetas(metaInfo.metaTag, canonical);
  if (metaInfo.linkingData)
    addPageSchema(metaInfo.linkingData, canonical);
}
function addMetas(metaTag, insertBeforeElement) {
  ["name", "property"].forEach((propName) => {
    if (metaTag[propName])
      Object.keys(metaTag[propName]).forEach((key) => addMeta(propName, key, metaTag[propName][key], insertBeforeElement));
  });
}
function addMeta(type, key, value, insertBeforeElement) {
  var metaElement = document.createElement("meta");
  metaElement.setAttribute("data-head", "tezjs");
  const typeSetterProp = type === "name" ? "name" : "title";
  if (type !== "charset") {
    metaElement[typeSetterProp] = key;
    metaElement.content = value;
  } else
    metaElement.setAttribute(type, value);
  document.head.insertBefore(metaElement, insertBeforeElement);
}
function addPageSchema(linkingData, insertBeforeElement) {
  linkingData.split("--").forEach((data) => {
    let scriptElement = document.createElement("script");
    scriptElement.setAttribute("data-head", "tezjs");
    scriptElement.type = "application/ld+json";
    scriptElement.textContent = data.trim();
    document.head.insertBefore(scriptElement, insertBeforeElement);
  });
}

function getCurrentUrl() {
  return window.location.pathname;
}

function subStringText(url) {
  if (url && url.length > 1 && url.substr(url.length - 1, url.length) === "/")
    url = url.substr(0, url.length - 1);
  return url;
}

function getUrl$1(url) {
  return url === "/" ? "/index" : url === "/index" ? "/" : subStringText(url);
}

function getUrl(baseUrl) {
  const url = baseUrl || getCurrentUrl();
  return getUrl$1(url);
}

function isTitleElementExist() {
  return document.getElementsByTagName("title")[0] !== void 0;
}

const tezPages = new class {
  constructor() {
    this.components = {};
    this.masterPages = {};
    this.pages = {};
    this.urlReference = {};
    this.isInitializationMode = true;
  }
  setComponents(components) {
    Object.keys(components).forEach((key) => {
      if (!this.components[key])
        this.components[key] = components[key];
    });
  }
  setMasterPage(masterPage) {
    if (masterPage)
      Object.keys(masterPage).forEach((key) => {
        if (!this.masterPages[key])
          this.masterPages[key] = masterPage[key];
      });
  }
  setUrlReference(url, referenceStateUrl) {
    this.urlReference[url] = referenceStateUrl;
  }
  getUrlReference(url) {
    return this.urlReference[url];
  }
  setPage(page) {
    if (page.payload) {
      let url = page.payload.url || getUrl();
      if (!this.pages[url])
        this.pages[url] = { ...page.payload, ...{ postScript: page.postScript } };
      else {
        Object.keys(page.payload.slots).forEach((slotName) => {
          if (!this.pages[url].slots[slotName])
            this.pages[url].slots[slotName] = [];
          if (this.pages[url].slots && this.pages[url].slots[slotName])
            page.payload.slots[slotName].forEach((item) => {
              let component = this.pages[url].slots[slotName].filter((t) => t.id === item.id)[0];
              if (component)
                component.data = item.data;
            });
        });
      }
      if (this.isInitializationMode) {
        this.isInitializationMode = false;
        this.refreshRoute(url);
      }
    }
    if (!isTitleElementExist() && page.payload && page.payload.isPage && page.payload.tags)
      setMetaInfo(page.payload.tags);
  }
  refreshRoute(url) {
    let urlReference = this.getUrlReference(url) || url;
    let currentPage = this.pages[urlReference];
    activePageState.setActivePage({
      layoutName: currentPage.layoutName,
      slots: currentPage.slots,
      masterPageSlots: currentPage.masterPageSlots,
      url: currentPage.url,
      postScript: currentPage.postScript
    });
  }
  getPayload(to) {
    let url = to || getUrl();
    return this.pages[url];
  }
  isExits(url) {
    let requestedUrl = getUrl(url);
    return this.pages[requestedUrl] !== void 0;
  }
  registerPage(page) {
    this.setComponents(page.components);
    this.setMasterPage(page.masterPage);
    this.setPage(page);
  }
}();

function getCurrentScrollPosition() {
  return {
    left: window.pageXOffset,
    top: window.pageYOffset
  };
}

const assign = Object.assign;
class Router {
  constructor() {
    this.historyState = { value: history.state };
    this.url = getCurrentUrl();
    this.currentUrl = this.url;
    const { pathname, search, hash } = location;
    this.url = pathname + search + hash;
    if (!this.historyState.value)
      this.changeRoute(this.url, {
        back: null,
        current: this.url,
        forward: null,
        position: history.length - 1,
        replaced: true,
        scroll: null
      }, true);
    window.addEventListener("popstate", ({ state }) => {
      this.historyState.value = state;
      this.changeRouteState(state && state.current ? state.current : getCurrentUrl(), true).then((t) => {
        const hash2 = location.hash;
        if (hash2) {
          let element = document.getElementById(hash2.replace("#", ""));
          if (element)
            element.scrollIntoView();
        }
      });
    });
  }
  push(to) {
    if (typeof to === "string")
      this.changeRouteState(to);
    else if (to.path) {
      this.routeOptions = to;
      this.changeRouteState(to.path);
    }
  }
  changeRouteState(to, isPopState = false) {
    this.changeScrollPosition();
    return this.resolve(to).then((t) => {
      this.refreshPageMetaTags(to);
      if (!isPopState) {
        const currentState = assign({}, this.historyState.value, history.state, {
          forward: to,
          scroll: getCurrentScrollPosition()
        });
        this.changeRoute(currentState.current, currentState, true);
        const state = assign({}, this.createState({ back: this.currentUrl, current: to, forward: null }), { position: currentState.position + 1 });
        this.changeRoute(to, state, false);
        this.routeOptions = void 0;
      }
      this.currentUrl = to;
      tezPages.refreshRoute(to);
    });
  }
  resolve(url) {
    return resolveRoute(url);
  }
  refreshPageMetaTags(to) {
    let payload = tezPages.getPayload(to);
    if (payload && payload.tags)
      setMetaInfo(payload.tags);
  }
  changeRoute(url, state, replace) {
    history[replace ? "replaceState" : "pushState"](state, "", !replace ? this.getFullUrl(url) : url);
    this.historyState.value = state;
  }
  getFullUrl(url) {
    let queryParams = "";
    if (this.routeOptions && this.routeOptions.query) {
      queryParams = "?";
      Object.keys(this.routeOptions.query).forEach((key) => {
        queryParams += `${key}=${this.routeOptions.query[key]}`;
      });
    }
    return `${url}${queryParams}`;
  }
  changeScrollPosition() {
    if ("scrollBehavior" in document.documentElement.style)
      window.scrollTo({
        behavior: "smooth",
        top: 0
      });
    else {
      window.scrollTo(window.pageXOffset, 0);
    }
  }
  createState(state) {
    return {
      back: state.back,
      current: state.current,
      forward: state.forward,
      replaced: state.replaced,
      position: window.history.length,
      scroll: getCurrentScrollPosition()
    };
  }
}

const componentState = new class {
  constructor() {
    this.tezAppOptions = void 0;
    this.currentRoute = shallowRef({ params: {} });
  }
  defineGlobalProps(app) {
    app.config.globalProperties.$tezRouter = new Router();
    Object.defineProperty(app.config.globalProperties, "$tezRoute", {
      enumerable: true,
      get: () => unref(this.currentRoute)
    });
  }
  changeRouteValue(routeValue) {
    this.currentRoute.value = routeValue;
  }
}();

const urlMatch = (urlPatten, url) => {
  const RIGHT_SLASH = "/";
  const splitUPattern = urlPatten.split(RIGHT_SLASH);
  const splitUrl = url.split(RIGHT_SLASH);
  let isMatched = splitUPattern.length === splitUrl.length;
  let params = {};
  if (isMatched)
    for (let i = 0; i < splitUPattern.length; i++) {
      if (/:/.test(splitUPattern[i])) {
        params[splitUPattern[i].replace(":", "")] = splitUrl[i];
        isMatched = true;
      } else
        isMatched = splitUPattern[i].toLowerCase() === splitUrl[i].toLowerCase();
      if (!isMatched)
        break;
    }
  return isMatched ? { params } : isMatched;
};
function checkAutoRoute(path) {
  let route = {};
  if (componentState.tezAppOptions.dynamicRoutes) {
    {
      const urlPattern = Object.keys(componentState.tezAppOptions.dynamicRoutes);
      for (const url of urlPattern) {
        const match = urlMatch(url, path);
        if (match) {
          route.resolvePath = componentState.tezAppOptions.dynamicRoutes[url];
          route.params = match.params;
          break;
        }
      }
    }
  }
  return route;
}

function getVersion() {
  return window.localStorage.getItem("tzV");
}
function getPreloadScriptUrl(url) {
  return componentState.tezAppOptions.isDevMode ? `/tez/deps${url}/preload.js?v=${getVersion()}` : `${url}/preload.${componentState.tezAppOptions.buildVersion}.js`;
}
function getPreScriptUrl(url) {
  return componentState.tezAppOptions.isDevMode ? `/tez/deps${url}/pre.js?v=${getVersion()}` : `${url}/pre.${componentState.tezAppOptions.buildVersion}.js`;
}
function getDynamicRouteScriptUrl() {
  return componentState.tezAppOptions.isDevMode ? `/tez/deps/dynamic-routes.js?v=${getVersion()}` : `/assets/dynamic-routes.${componentState.tezAppOptions.buildVersion}.js`;
}

const seen = /* @__PURE__ */ new Set();
function preloadDependencies(baseModule, deps) {
  const base = "/";
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = `${base}${dep}`;
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : "modulepreload";
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", rej);
      });
    }
  })).then(() => baseModule());
}

function registerDynamicRoutes(routes) {
  componentState.tezAppOptions.dynamicRoutes = routes;
}

function registerTezPage(page) {
  tezPages.registerPage(page);
}

const WINDOW_TEZ_DATA = "TEZ_DATA";
function registerData(resolve) {
  return (func) => {
    func(registerTezPage, preloadDependencies);
    resolve(true);
  };
}
async function resolveRoute(url) {
  return resolvePreloadCode(componentState.tezAppOptions, url);
}
async function resolvePreloadCode(tezAppOptions, to) {
  return new Promise((resolve, reject) => {
    let url = getUrl(to);
    if (!tezPages.isExits(url)) {
      import(
        /* @vite-ignore */
        getPreloadScriptUrl(url)
      ).then((t) => t.default).then((t) => {
        t(preloadDependencies).then((t2) => t2.default).then(registerData(resolve));
      }).catch(failedRoute(url, resolve));
    } else
      resolve(true);
  });
}
async function resolvePreCode(tezAppOptions, to) {
  return new Promise((resolve, reject) => {
    let url = getUrl(to);
    if (window[WINDOW_TEZ_DATA]) {
      registerData(resolve)(window[WINDOW_TEZ_DATA]);
      delete window[WINDOW_TEZ_DATA];
      return;
    }
    if (!tezPages.isExits(url)) {
      import(
        /* @vite-ignore */
        getPreScriptUrl(url)
      ).then((t) => t.default).then(registerData(resolve)).catch(failedRoute(url, resolve));
    } else
      resolve(true);
  });
}
function resolveDynamicRoute() {
  return new Promise((resolve, reject) => {
    if (!componentState.tezAppOptions.dynamicRoutes) {
      import(
        /* @vite-ignore */
        getDynamicRouteScriptUrl()
      ).then((t) => t.default).then((func) => {
        func(registerDynamicRoutes);
        resolve(true);
      });
    } else
      resolve(true);
  });
}
function failedRoute(url, resolve) {
  return (reason) => {
    resolveDynamicRoute().then((isSet) => {
      let dynamicRoutes = componentState.tezAppOptions.dynamicRoutes;
      if (dynamicRoutes && Object.keys(dynamicRoutes).length > 0) {
        let route = checkAutoRoute(url);
        if (route.resolvePath) {
          resolvePreloadCode(componentState.tezAppOptions, route.resolvePath).then((t) => {
            componentState.changeRouteValue({ params: route.params });
            tezPages.setUrlReference(url, route.resolvePath);
            resolve(true);
          });
        }
      }
    });
  };
}

const cacheState = new class {
  constructor() {
    this.layoutVNode = {};
    this.pageVnodes = {};
    this.cachedRoute = {};
    this.routes = {};
    this.cachedRouteCount = 0;
  }
  addRoute(route) {
    const clientConfig = componentState.tezAppOptions.clientConfig;
    if (clientConfig?.preCache?.route) {
      const routeConfig = clientConfig?.preCache?.route;
      route = route.toLowerCase();
      const isCache = routeConfig === true || routeConfig.test(route);
      if (!this.cachedRoute[route] && !this.routes[route] && isCache) {
        this.routes[route] = true;
        if (this.cachedRouteCount > 0)
          idleCallback(() => this.preCacheRoutes(route), { timeout: 10 });
      }
    }
  }
  preCacheRoutes(routePath) {
    const routes = routePath ? [routePath] : Object.keys(this.routes);
    for (const route of routes) {
      delete this.routes[route];
      resolveRoute(route);
      this.cachedRoute[route] = true;
      this.cachedRouteCount++;
    }
  }
  cacheVNode(id, vNode) {
    let url = getUrl();
    if (!this.pageVnodes[url])
      this.pageVnodes[url] = {};
    this.pageVnodes[url][id] = vNode;
    return vNode;
  }
  getVNode(id) {
    let url = getUrl();
    if (!this.pageVnodes[url])
      return;
    return this.pageVnodes[url][id];
  }
}();

let isExecuted = false;
function runAddLib() {
  if (!isExecuted) {
    isExecuted = true;
    setTimeout(() => {
      if (componentState.tezAppOptions.libConfig) {
        const libConfig = componentState.tezAppOptions.libConfig;
        if (libConfig.runOn) {
          let idleTime = libConfig.runOn.idleTime;
          for (let idleTimeFunc of idleTime) {
            idleTimeFunc();
          }
        }
        if (libConfig.afterUserInteraction)
          afterUserInteraction(libConfig.afterUserInteraction);
      }
      cacheState.preCacheRoutes();
    }, 2500);
  }
}

const TezSlot = defineComponent({
  data() {
    return {
      scrollFunction: null,
      isScrolled: false,
      postScript: null,
      previousState: null,
      isInView: false,
      lazyRef: null,
      observer: null,
      slots: {},
      masterPageSlots: {},
      components: new Array(),
      nextIndex: 0
    };
  },
  props: {
    slotName: { type: String, default: "default" },
    slotCategory: { type: String, default: "page" },
    preserveComponentState: { type: Boolean }
  },
  async mounted() {
    this.slots = activePageState.page.slots;
    this.masterPageSlots = activePageState.page.masterPageSlots;
    this.postScript = activePageState.page.postScript;
    if (this.slotCategory !== "master") {
      if (!isBot())
        this.subscribeScroll();
      activePageState.hooks.hook("tez:activePageChanged", (pageState) => {
        this.slots = pageState.slots;
        this.masterPageSlots = pageState.masterPageSlots;
        this.postScript = pageState.postScript;
        this.components = new Array();
        this.nextIndex = 0;
        this.goToNextComponent(true);
      });
    }
    this.goToNextComponent(true);
  },
  methods: {
    subscribeScroll() {
      this.scrollFunction = this.onScroll.bind(this);
      window.addEventListener("scroll", this.scrollFunction);
    },
    async onScroll() {
      if (!this.isScrolled) {
        this.isScrolled = true;
        window.removeEventListener("scroll", this.scrollFunction);
        await this.loadPostScript();
        this.isInView = true;
        this.goToNextComponent();
      }
    },
    getSlotComponents(slotName, slotCategory) {
      if (slotCategory === "master") {
        return this.masterPageSlots[slotName] ? this.masterPageSlots[slotName] : [];
      }
      return this.slots[slotName] ? this.slots[slotName] : [];
    },
    subscribeLazy() {
      if (this.$refs.divLazy) {
        let isContinue = false;
        this.observer = new IntersectionObserver(async ([{ isIntersecting }]) => {
          this.isInView = isIntersecting;
          if (isIntersecting && this.previousState !== isIntersecting) {
            if (this.nextIndex == this.getMaxPreComponentCount() && this.postScript)
              await this.loadPostScript();
            this.goToNextComponent(isContinue);
          }
          this.previousState = isIntersecting;
          isContinue = true;
        });
        this.observer.observe(this.$refs.divLazy);
      }
    },
    getMaxPreComponentCount() {
      return componentState.tezAppOptions.maxPreComponentCount;
    },
    async goToNextComponent(isContinue) {
      if (isContinue === false)
        return;
      if (!this.observer && !isBot()) {
        this.subscribeLazy();
        this.isInView = isContinue;
        if (!this.isInView)
          return;
      }
      this.isInView = isContinue || isBot() || this.isInView;
      if (this.isInView) {
        let components = this.getSlotComponents(this.slotName, this.slotCategory);
        let _components = [];
        if (this.nextIndex == this.getMaxPreComponentCount() && this.postScript || this.postScript && isBot())
          await this.loadPostScript();
        if (components.length > this.nextIndex && !this.components[this.nextIndex]) {
          let increCount = isBot() ? components.length : this.nextIndex == this.getMaxPreComponentCount() + 1 ? components.length : this.nextIndex + 1;
          let startIndex = this.nextIndex;
          for (var i = startIndex; i < increCount; i++) {
            let componentItem = components[this.nextIndex];
            let componentName = this.getComponentName(componentItem);
            if (tezPages.components[componentName]) {
              _components.push(componentItem);
              this.nextIndex++;
              if (increCount !== components.length)
                idleCallback(() => this.goToNextComponent(), { timeout: 0 });
            }
          }
          _components.forEach((component) => this.components.push(component));
          if (this.slotCategory === "page" && components.length === this.components.length && components.length === 1)
            runAddLib();
        }
      } else if (this.slotCategory === "page")
        runAddLib();
    },
    loadPostScript() {
      if (this.postScript)
        return this.postScript().then((postScript) => {
          postScript.default(registerTezPage);
          this.postScript = null;
        });
    },
    getComponentName(component) {
      return isMobile() && component.mobileComponentName ? component.mobileComponentName : component.name;
    }
  },
  render() {
    let vNodes = new Array();
    for (let component of this.components) {
      let componentName = this.getComponentName(component);
      let vNode = cacheState.getVNode(component.id);
      if (!vNode)
        vNode = cacheState.cacheVNode(component.id, h(tezPages.components[componentName], { data: component.data }));
      vNodes.push(h(KeepAlive, { key: `${getCurrentUrl()}${component.itemName}` }, vNode));
    }
    if (!this.lazyRef)
      this.lazyRef = h("div", { ref: "divLazy", style: { "height": "2px" } }, "");
    vNodes.push(this.lazyRef);
    return h("div", vNodes);
  }
});

const TezIndex = defineComponent({
  render() {
    return h(TezSlot);
  }
});

function getPayloadPath(url) {
  return `/payload${url}`;
}

async function getJsonPayload(name, refUrl) {
  const url = getUrl(refUrl);
  const fileName = name ? name : url.split("/").pop();
  const response = await fetch(getPayloadPath(`${url}/${fileName}.json`));
  const data = await response.json();
  return data;
}

const TezLazy = defineComponent({
  data() {
    return {
      items: [],
      lazyRef: null,
      observer: null,
      index: 0,
      lastItem: null
    };
  },
  props: ["sourcePath", "currentPage", "class"],
  watch: {
    currentPage(value) {
      if (this.index != value) {
        this.index = value;
        this.loadJson();
      }
    }
  },
  mounted() {
    this.subscribeLazy();
  },
  methods: {
    subscribeLazy() {
      if (this.$refs.divLazy) {
        this.observer = new IntersectionObserver(async ([{ isIntersecting }]) => {
          if (isIntersecting) {
            this.index++;
            this.loadJson();
          }
        });
        this.observer.observe(this.$refs.divLazy);
      }
    },
    async loadJson() {
      if (this.sourcePath && (!this.lastItem || this.lastItem.totalCount > this.index * this.lastItem.items.length)) {
        let source = await getJsonPayload(String(this.index), `/${this.sourcePath}`);
        source.items.forEach((t) => {
          this.items.push(t);
        });
        this.lastItem = source;
      } else if (this.observer)
        this.observer.unobserve(this.$refs.divLazy);
    }
  },
  render() {
    let vNodes = new Array();
    if (this.$slots && this.$slots.default && this.items && this.items.length > 0)
      vNodes.push(h("div", { class: this.class }, this.$slots?.default({
        items: this.items
      })));
    if (!this.lazyRef)
      this.lazyRef = h("div", { ref: "divLazy" }, "");
    vNodes.push(this.lazyRef);
    return h("div", vNodes);
  }
});

const TezPage = defineComponent({
  data() {
    return {
      vNode: h("div")
    };
  },
  render() {
    this.vNode = h(TezSlot);
    return h(h(KeepAlive, null, this.vNode));
  }
});

const TAG = "a";
function isPush(event) {
  if (event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    return;
  if (event.defaultPrevented)
    return;
  if (event.button !== void 0 && event.button !== 0)
    return;
  if (event.currentTarget && event.currentTarget.getAttribute) {
    const target = event.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (event.preventDefault)
    event.preventDefault();
  return true;
}
const TezLink = defineComponent({
  props: ["to", "class"],
  mounted() {
    cacheState.addRoute(this.to);
  },
  render() {
    let children = this.$slots.default ? this.$slots.default() : void 0;
    return h(TAG, {
      onClick: (e) => {
        if (isPush(e))
          this.$tezRouter.push(this.to);
      },
      href: this.to,
      class: this.class
    }, children);
  }
});

function getScreenSize() {
  if (typeof window !== "undefined")
    return screen.width;
  return 0;
}

const NODE_NAME = "div";
const TezIterator = defineComponent({
  data() {
    return {
      sourceItems: [],
      isInteractive: false,
      observer: null,
      lazyRef: null,
      lastIndex: 0,
      defaultCount: 10
    };
  },
  props: ["items", "class", "childClass", "countSM", "countMD", "countLG", "countXL", "vNode", "vChildNode"],
  computed: {
    pickCount: {
      get() {
        let count = this.defaultCount;
        const screenSize = getScreenSize();
        if (screenSize >= 1200)
          count = this.countXL || this.defaultCount;
        else if (screenSize >= 992)
          count = this.countLG || this.defaultCount;
        else if (screenSize >= 768)
          count = this.countMD || this.defaultCount;
        else
          count = this.countSM || this.defaultCount;
        return parseInt(count);
      },
      set(v) {
      }
    }
  },
  watch: {
    items: function(value) {
      this.bindNext();
    }
  },
  mounted() {
    this.subscribeLazy();
  },
  methods: {
    subscribeLazy() {
      if (this.$refs.divLazy) {
        this.observer = new IntersectionObserver(async ([{ isIntersecting }]) => {
          this.isInteractive = isIntersecting;
          if (isIntersecting)
            this.bindNext();
        });
        this.observer.observe(this.$refs.divLazy);
      }
    },
    bindNext() {
      if (this.isInteractive) {
        if (this.sourceItems.length <= this.items.length) {
          let length = this.items.length;
          let pickCount = this.pickCount;
          length = this.items.length > this.lastIndex + pickCount ? this.lastIndex + pickCount : this.lastIndex + (this.items.length - this.sourceItems.length);
          for (var i = this.lastIndex; i < length; i++) {
            let item = this.items[i];
            this.sourceItems.push(item);
          }
          this.lastIndex = length;
        }
      }
    }
  },
  render() {
    let vNodes = new Array();
    if (this.$slots && this.$slots.default)
      this.sourceItems.forEach((item, index) => {
        let slot = this.$slots && this.$slots.default ? this.$slots.default({ ...item }) : [];
        vNodes.push(h(this.vChildNode || NODE_NAME, { class: this.childClass, key: index }, slot));
      });
    if (this.sourceItems.length > 0)
      idleCallback(this.bindNext, { timeout: 2e3 });
    if (!this.lazyRef)
      this.lazyRef = h("div", { ref: "divLazy" }, "");
    vNodes.push(this.lazyRef);
    return h(this.vNode || NODE_NAME, { class: this.class }, vNodes);
  }
});

const TzTickedMixin = {
  mounted: function() {
    const _this = this;
    _this.$nextTick(function() {
      if (_this.$parent?.$parent?.$parent?.tzTicked)
        setTimeout(() => {
          _this.$parent.$parent.$parent.tzTicked();
        }, 10);
    });
  }
};

const imageLoader = new class {
  constructor() {
    this.cachedImage = {};
    this.resolveRequest = {};
    this.imageRequestBroadcaster = void 0;
  }
  register() {
    if (window.location.hostname.indexOf("localhost") === -1) {
      this.imageRequestBroadcaster = new Worker(`/tz.${componentState.tezAppOptions.buildVersion}.js`);
      this.imageRequestBroadcaster.onmessage = (event) => {
        if (this.resolveRequest[event.data.url]) {
          this.cachedImage[event.data.url] = event.data.baseString;
          this.resolveRequest[event.data.url].forEach((resolve) => resolve(event.data.baseString));
          delete this.resolveRequest[event.data.url];
        }
      };
    }
  }
  getImage(url) {
    return this.cachedImage[url];
  }
  resolve(url) {
    return new Promise((resolve, reject) => {
      if (!this.cachedImage[url]) {
        if (!this.resolveRequest[url])
          this.resolveRequest[url] = [resolve];
        else
          this.resolveRequest[url].push(resolve);
        this.imageRequestBroadcaster.postMessage({
          url
        });
      } else
        resolve(this.cachedImage[url]);
    });
  }
}();

const TEZ_SRC_DIRECTIVE = {
  beforeMount: function(el, binding, vnode, prevVnode) {
    if (!isBot()) {
      const cachedImage = imageLoader.getImage(binding.value);
      if (cachedImage) {
        el.src = cachedImage;
        return;
      }
      if (componentState.tezAppOptions.loaderImagePath)
        el.src = componentState.tezAppOptions.loaderImagePath;
      let observer = new IntersectionObserver(function(entries) {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (window.location.hostname.indexOf("localhost") === -1)
              imageLoader.resolve(binding.value).then((image) => el.src = image);
            else
              el.src = binding.value;
            observer.unobserve(el);
          }
        });
      }, { threshold: [0.25] });
      observer.observe(el);
      el.observer = observer;
    } else
      el.src = binding.value;
  }
};

const tez = new class {
  register(tezAppOptions) {
    return {
      install(Vue) {
        if (tezAppOptions.useVue)
          tezAppOptions.useVue(Vue);
        componentState.defineGlobalProps(Vue);
        Vue.component("TezIndex", TezIndex);
        Vue.component("TezSlot", TezSlot);
        Vue.component("TezLazy", TezLazy);
        Vue.component("TezPage", TezPage);
        Vue.component("TezLink", TezLink);
        Vue.component("TezIterator", TezIterator);
        Vue.directive("tez-src", TEZ_SRC_DIRECTIVE);
        Vue.mixin(TzTickedMixin);
      }
    };
  }
}();

const CACHE_KEY_LAYOUT_TEZ_PAGE = "layout_tezpage";
const TezView = defineComponent({
  data() {
    return {
      state: {},
      tezNode: h(TezIndex),
      vNode: void 0,
      layoutName: void 0,
      layoutComponent: void 0
    };
  },
  mounted() {
    this.layoutName = activePageState.page.layoutName;
    this.layoutComponent = activePageState.page.layoutComponent;
    this.subscribeHooks();
  },
  methods: {
    subscribeHooks() {
      activePageState.hooks.hook("tez:layoutNameChanged", (layoutName) => {
        this.layoutName = layoutName;
      });
      activePageState.hooks.hook("tez:layoutComponentChanged", (component) => {
        this.layoutComponent = component;
      });
    }
  },
  render() {
    let vNode = void 0;
    let layoutComponent = tezPages.masterPages[this.layoutName];
    if (typeof layoutComponent === "function")
      tezPages.masterPages[this.layoutName] = layoutComponent = defineAsyncComponent(layoutComponent);
    if (!layoutComponent)
      cacheState.layoutVNode[CACHE_KEY_LAYOUT_TEZ_PAGE] = vNode = cacheState.layoutVNode[CACHE_KEY_LAYOUT_TEZ_PAGE] || h(TezPage);
    else if (layoutComponent)
      cacheState.layoutVNode[this.layoutName] = vNode = cacheState.layoutVNode[this.layoutName] || h(layoutComponent);
    return h(h(KeepAlive, null, vNode));
  }
});

function createTezApp(tezAppOptions) {
  componentState.tezAppOptions = tezAppOptions;
  imageLoader.register();
  resolvePreCode().then((t) => createApp(TezView).use(tez.register(tezAppOptions)).mount("#tez_app"));
}

function addPreCacheAssets() {
  let message = getMessage();
  if (message)
    navigator.serviceWorker.getRegistration().then((registration) => {
      if ("active" in registration && navigator.onLine) {
        registration.active.postMessage(message);
      }
    });
}
function getMessage() {
  return window["TEZ_PRE_CACHE_ASSETS"];
}

export { addPreCacheAssets, createTezApp, imageLoader, registerTezPage };
