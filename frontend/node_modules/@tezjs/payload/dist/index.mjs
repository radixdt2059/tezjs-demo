import { commonContainer, isObject as isObject$1, isArray, CommonPathResolver, getPath, createPath, writeFileSync as writeFileSync$1, readFileSync } from '@tezjs/common';
import axios from 'axios';
import * as path from 'path';
import * as qs from 'qs';
import * as fs from 'fs';
import * as crypto from 'crypto';

const MARK_DOWN_CONFIG = {
  preset: "default",
  linkify: true,
  breaks: true,
  injected: true,
  html: true,
  use: []
};

const NAME = "name";
const DESCRIPTION = "description";
const KEYWORDS = "keywords";
const LOADING = "loading";
const LAZY = "lazy";
const SRC = "src";
const HTTPS = "https";
const TITLE = "title";
const EQUALTO = "=";
const EQUALTO_SPACE = " = ";
const SPACE = " ";
const PIPE = "||";
const ALT = "alt";
const AND_OPERATOR = "&";
const CHARSET = "charset";
const PROPERTY = "property";
const FIELD_COMPONENT_TYPE_NAME = "__component";
const META_TAGS_COMPONENT_NAME = "tags.meta-tags";
const META_TAGS_SEO_COMPONENT_NAME = "tags.seo";
const FIELD_COMPONENT_NAME_GET_ALL_DATA = "data-control.get-all-data";
const FIELD_COMPONENT_NAME_GET_DATA_FIELD_VALUE = "data-control.get-data-by-field-value";
const FIELD_DATA_TYPE_RESULT = "DataTypeResult";
const META_TAGS = "MetaTags";
const TAGS_SEO = "SEO";
const VUE_REFERENCE_CODE = "VueReferenceCode";
const DATA_CONTROL_ALL = "GetAllData";
const DATA_CONTROL_GET_RECORD = "GetRecord";
const DATA_CONTROL_FILTER = "GetFilterData";
const UNDERSCORE = "_";
const URL_PROPS = ["url", "navurl", "slug"];
const TITLE_PROPS = ["title", "name"];
const COMPONENT_DATA_PROPS = ["genericsection", "genericcollections"];
const COLLECTION_TYPE_PROPS = ["collectiontype"];
const VUE_COMPONENT_NAME_PROPS = ["vuecomponentname", "vuereferencecode", "componentname"];
const PRE_SECTION_PROPS = ["headersection", "pre", "precomponents"];
const POST_SECTION_PROPS = ["footersection", "post", "postcomponents"];
const COMPONENT_REFERENCE_PATH = ["componentreferencepath"];
const VUE_COMPONENT_NAME = "VueComponentName";
const ASTERISK = "*";
const BLANK = "";
const DYNAMIC_PROP_NAMES = ["dynamicpage", "referencepages"];
const CONTENT_PROP_NAMES = ["content"];
const META_TAG_PROP_NAMES = ["metatags"];
const SEO_PROP_NAMES = ["seo"];
const UPDATED_AT = ["updated_at", "updatedat"];
const CHANGE_FREQUENCY = ["changefrequency"];
const PRIORITY = ["priority"];
const DEFAULT_STRAPI_URL = "http://localhost:1337";
const IMAGE_EXTENSION_REGEX = /\.(gif|jpe?g|tiff?|png|webp|bmp|svg)$/i;

const defaultContainer = new class {
  constructor() {
    this.writeImageUris = new Array();
    this.dynamicPageCollection = {};
    this.collectionState = {};
    this.filterCollectionState = {};
    this.nuxtInstance = void 0;
  }
  getUniqueId() {
    return String(parseInt(String(Math.random() * 1e7)));
  }
  cacheDynamicPageCollection(collectionName, data) {
    this.dynamicPageCollection[collectionName] = data;
  }
  getDynamicPageCollection(collectionName, filterExpression) {
    return this.dynamicPageCollection[collectionName] ? this.dynamicPageCollection[collectionName].filter(filterExpression) : [];
  }
  clearState() {
    this.filterCollectionState = {};
    this.collectionState = {};
    this.dynamicPageCollection = {};
  }
}();

function urlReplacer(value, columnName) {
  if (typeof value === "string" && value.indexOf("https://") !== -1) {
    let strapiConfig = commonContainer.getStrapiConfig();
    if (strapiConfig.media.cdnUri && strapiConfig.media.uris.length > 0) {
      const imageHostUris = typeof strapiConfig.media.uris === "string" ? JSON.parse(strapiConfig.media.uris) : strapiConfig.media.uris;
      const cdnHost = strapiConfig.media.cdnUri;
      imageHostUris.forEach((host) => {
        value = value.replace(host, cdnHost);
      });
    }
  } else {
    if (typeof value === "string" && IMAGE_EXTENSION_REGEX.test(value) && columnName == "url")
      defaultContainer.writeImageUris.push(value);
  }
  return value;
}

function findFirstMatchingConfig(link, configs) {
  var i, config;
  var href = link.attrs[link.attrIndex("href")][1];
  for (i = 0; i < configs.length; ++i) {
    config = configs[i];
    if (!config.pattern || new RegExp(config.pattern).test(href)) {
      return config;
    }
  }
}
function applyAttributes(idx, tokens, attributes) {
  Object.keys(attributes).forEach(function(attr) {
    var attrIndex;
    var value = attributes[attr];
    if (attr === "className") {
      attr = "class";
    }
    attrIndex = tokens[idx].attrIndex(attr);
    if (attrIndex < 0) {
      tokens[idx].attrPush([attr, value]);
    } else {
      tokens[idx].attrs[attrIndex][1] = value;
    }
  });
}
function markdownitLinkAttributes(md, configs) {
  if (!configs) {
    configs = [];
  } else {
    configs = Array.isArray(configs) ? configs : [configs];
  }
  Object.freeze(configs);
  var defaultRender = md.renderer.rules.link_open || this.defaultRender;
  md.renderer.rules.link_open = function(tokens, idx, options, env, self) {
    var config = findFirstMatchingConfig(tokens[idx], configs);
    var attributes = config && config.attrs;
    if (attributes) {
      applyAttributes(idx, tokens, attributes);
    }
    return defaultRender(tokens, idx, options, env, self);
  };
}
markdownitLinkAttributes.defaultRender = function(tokens, idx, options, env, self) {
  return self.renderToken(tokens, idx, options);
};

const MarkdownIt = require("markdown-it")(MARK_DOWN_CONFIG);
const imageDefaultRender = MarkdownIt.renderer.rules.image;
MarkdownIt.use(markdownitLinkAttributes, {
  pattern: /^https:/,
  attrs: {
    target: "_blank",
    rel: "noopener nofollow"
  }
});
MarkdownIt.renderer.rules.image = function(tokens, idx, options, env, self) {
  try {
    const imageCdn = commonContainer.getStrapiConfig().media.cdnUri;
    const token = tokens[idx];
    token.attrs.push([LOADING, LAZY]);
    let titleText = "";
    let atributeNode = [];
    let jObject = {};
    token.attrs.forEach((t) => {
      switch (t[0]) {
        case SRC:
          if (t[1].indexOf(HTTPS) !== -1) {
            t[1] = urlReplacer(t[1]);
          } else {
            t[1] = imageCdn + t[1];
          }
          break;
        case TITLE:
          titleText = t[1];
          let splitText = titleText.split(/{{(.*?)}}/);
          splitText.forEach((t2) => {
            if (t2) {
              if (t2.indexOf(EQUALTO) !== -1) {
                t2 = t2.replace(EQUALTO_SPACE, EQUALTO).trim();
                let splitSpace = t2.split(SPACE);
                splitSpace.forEach((x) => {
                  let splitEqual = x.split(EQUALTO);
                  jObject[splitEqual[0]] = splitEqual[1];
                });
              }
            }
          });
          token.content = splitText[splitText.length - 1].trim();
          splitText = token.content.split(PIPE);
          t[1] = splitText[0];
          if (token.children && token.children.length > 0) {
            token.children[0].content = splitText[1];
          }
          if (atributeNode.length > 0) {
            atributeNode[1] = splitText[1];
          }
          break;
        case ALT:
          atributeNode = t;
          break;
      }
    });
    Object.keys(jObject).forEach((t) => {
      token.attrs.push([t, jObject[t]]);
    });
  } catch (e) {
  }
  return imageDefaultRender(tokens, idx, options, env, self);
};

function toCamelCase(value) {
  if (commonContainer.getStrapiConfig().serializeJson.isCamelCase)
    return value.length > 1 ? `${value.charAt(0).toLowerCase()}${value.substr(1, value.length)}` : value.toLowerCase();
  return value;
}

function clear(jsonObject, isRoot) {
  let htmlSanitizer = commonContainer.tezConfig.payload.page.htmlSanitizer;
  var jObject = {};
  Object.keys(jsonObject).forEach((t) => {
    var keyName = toCamelCase(t);
    if (jsonObject[t] && isObject$1(jsonObject[t])) {
      if (!ignoreColumns(t)) {
        if (keyName === "attributes") {
          jObject = { ...jObject, ...clear(jsonObject[t]) };
        } else
          jObject[keyName] = clear(jsonObject[t]);
      }
    } else if (jsonObject[t] && isArray(jsonObject[t])) {
      if (!ignoreColumns(t)) {
        jObject[keyName] = [];
        for (let i = 0; i < jsonObject[t].length; i++) {
          jObject[keyName].push(clear(jsonObject[t][i]));
        }
      }
    } else if (jsonObject[t] !== null && jsonObject[t] !== "" && !ignoreColumns(t)) {
      var content = jsonObject[t];
      if (t === "LongText" || t === "Content") {
        var masterContent = content;
        content = MarkdownIt.render(masterContent);
        content = content ? content.split("\n").map((x) => x.trim()) : content;
        if (htmlSanitizer)
          content = htmlSanitizer(content);
        content = Array.isArray(content) ? content.join("") : content;
      }
      jObject[keyName] = urlReplacer(content, keyName);
    }
  });
  return jObject;
}
function ignoreColumns(name, isRoot) {
  let columns = commonContainer.getStrapiConfig().ignoreColumns || [];
  return columns.filter((t) => t === name)[0];
}
function cleanObject(jObject) {
  if (Array.isArray(jObject)) {
    let items = [];
    jObject.forEach((item) => {
      items.push(clear(item));
    });
    return items;
  }
  return clear(jObject);
}

function swapDataPropValue(jObject) {
  let jsonObject = {};
  if (Array.isArray(jObject) && jObject[0] && isObject$1(jObject[0])) {
    let items = [];
    jObject.forEach((item) => {
      items.push(swapDataPropValue(item));
    });
    return items;
  } else if (jObject && isObject$1(jObject)) {
    Object.keys(jObject).forEach((key) => {
      if (Array.isArray(jObject[key]) && jObject[key][0] && isObject$1(jObject[key][0])) {
        let items = [];
        jObject[key].forEach((item) => {
          items.push(swapDataPropValue(item));
        });
        if (key === "data")
          jsonObject = items;
        else
          jsonObject[key] = items;
      } else if (isObject$1(jObject[key])) {
        if (key === "data")
          jsonObject = swapDataPropValue(jObject[key]);
        else
          jsonObject[key] = swapDataPropValue(jObject[key]);
      } else
        jsonObject[key] = jObject[key];
    });
  }
  return jsonObject;
}

class RequestService {
  constructor() {
    const { apiUri, userCredential, version } = commonContainer.getStrapiConfig();
    this.apiUri = apiUri || DEFAULT_STRAPI_URL;
    this.userCredential = userCredential;
    this.apiString = version === 4 ? "/api" : "";
  }
  async get(uri) {
    const { data } = await axios.get(`${this.apiUri}${this.apiString}${uri}`, this.headers);
    return this.camalizeData(data.data);
  }
  camalizeData(data) {
    return swapDataPropValue(cleanObject(data));
  }
  async login() {
    if (this.userCredential) {
      const { data } = await axios.post(`${this.apiUri}/api/auth/local`, this.userCredential);
      this.token = data.jwt;
    }
  }
  get headers() {
    if (this.token)
      return {
        headers: {
          Authorization: `Bearer ${this.token}`
        }
      };
    else
      return {};
  }
  async payloadRequest(uri) {
    const { data } = await axios.get(uri, this.headers);
    return this.camalizeData(data.data);
  }
}

class InternationalizationService {
  constructor(requestService) {
    this.requestService = requestService;
    const { enableInternationalization, version } = commonContainer.getStrapiConfig();
    this.enableInternationalization = enableInternationalization;
    this.version = version;
  }
  async getLocales() {
    let locales = ["en"];
    if (this.enableInternationalization) {
      let data = await this.requestService.get(`/i18n/locales`);
      if (this.version === 4) {
        locales = [];
        data.forEach((item) => {
          locales.push(item.code);
        });
      }
    }
    return locales;
  }
}

const REMOVE_SPACE = new RegExp("[ ]+", "g");
const REMOVE_SPECIAL_CHARACTERS = new RegExp(/[^A-Z0-9]/ig);
const REMOVE_CURLY_BRACKETS = new RegExp(/\{{|}}/g);
const EXTRACT_CURLY_BRACKETS_STRING = new RegExp(/\{{[^)]*\}}/g);

function SnakeCaseSanitizer(text) {
  var newText = "";
  text.split("").forEach((t, i) => {
    if (t === t.toUpperCase() && i != 0)
      newText += "-" + t.toLowerCase();
    else
      newText += t.toLowerCase();
  });
  return newText;
}

const QUERY_PARAMS = {
  3: {
    limit: {
      "_limit": () => commonContainer.getStrapiConfig().limit
    },
    locale: {
      "_locale": (value) => value
    }
  },
  4: {
    limit: {
      pagination: {
        pageSize: () => commonContainer.getStrapiConfig().limit
      }
    },
    locale: {
      "locale": (value) => value
    },
    populate: { populate: "deep" },
    seoPopulate: { populate: "deep" }
  }
};

function getQueryString(queryParamsObject) {
  return qs.stringify(queryParamsObject, {
    encodeValuesOnly: true
  });
}

function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}

function getQueryParams(name, value = "") {
  const strapiVersion = commonContainer.getStrapiConfig().version;
  let queryParamsObject = void 0;
  let names = typeof name === "string" ? [name] : name;
  let queryString = "";
  names.forEach((name2) => {
    queryParamsObject = QUERY_PARAMS[strapiVersion][name2];
    if (queryParamsObject) {
      queryParamsObject = getParams(queryParamsObject, value);
      queryString += getQueryString(queryParamsObject);
      queryString += "&";
    }
  });
  return queryString;
}
function getParams(queryParamsObject, value) {
  var jObject = {};
  Object.keys(queryParamsObject).forEach((key) => {
    if (Array.isArray(queryParamsObject[key])) {
      jObject[key] = getParams(queryParamsObject[key], value);
    } else if (isObject(queryParamsObject[key])) {
      jObject[key] = getParams(queryParamsObject[key], value);
    } else
      jObject[key] = typeof queryParamsObject[key] === "function" ? queryParamsObject[key](value) : queryParamsObject[key];
  });
  return jObject;
}

function getUrl(url) {
  return url === "/" ? "/index" : url === "/index" ? "/" : url;
}

function mergeUrl(rootUrl, childUrl) {
  if (rootUrl.indexOf("/*") !== -1) {
    return rootUrl.replace("/*", childUrl);
  }
  return childUrl;
}

function readProp(jObject, props) {
  let value = null;
  if (jObject) {
    const objectProps = Object.keys(jObject);
    for (const prop of objectProps) {
      var isExits = props.filter((x) => x === prop.toLowerCase())[0];
      if (isExits) {
        value = jObject[prop];
        break;
      }
    }
  }
  return value;
}

async function writeFileSync(path, content, isString = false) {
  content = !isString ? JSON.stringify(content) : content;
  await fs.writeFileSync(path, content);
}

class PathResolver {
  constructor() {
    this.commonPath = new CommonPathResolver();
  }
  get componentsPath() {
    return this.commonPath.componentsPath;
  }
  get sourceCodePath() {
    return this.commonPath.sourceCodePath;
  }
  get publicFolder() {
    return this.commonPath.publicFolder;
  }
  get payloadPath() {
    return this.commonPath.payloadPath;
  }
  get rootPath() {
    return this.commonPath.cachePath;
  }
  get routesJsonPath() {
    return this.commonPath.routesJsonPath;
  }
  get robotsTxtPath() {
    return getPath([this.publicFolder, "robots.txt"]);
  }
  get redirectRoutesJsonPath() {
    return this.commonPath.redirectRoutesJsonPath;
  }
  get sitemapJsonPath() {
    return getPath([this.rootPath, "sitemap.json"]);
  }
  get globJsonPath() {
    return getPath([this.rootPath, "glob.json"]);
  }
  get routeComponentsPath() {
    return getPath([this.rootPath, "route-components.json"]);
  }
  get sitemapXmlPath() {
    return getPath([this.publicFolder, "sitemap.xml"]);
  }
  get sitemapNotMappedJsonPath() {
    return getPath([this.publicFolder, "sitemap-not-mapped.json"]);
  }
  getCollectionPayloadPath(collectionName) {
    return getPath([this.payloadPath, "collections", collectionName], true);
  }
  getFilterCollectionPayloadPath(collectionName) {
    return getPath([this.payloadPath, "filter-collections", collectionName], true);
  }
  pathExists(path) {
    return this.commonPath.pathExists(path);
  }
}

function dynamicRouteCodeTemplate(routes) {
  return `  export default function(registerDynamicRoute){
        registerDynamicRoute(${JSON.stringify(routes)})
    }    `;
}

class PageRoute {
  constructor(requestService) {
    this.requestService = requestService;
    this.routes = new Array();
    const { pageCollectionConfig } = commonContainer.getStrapiConfig();
    this.pageCollectionConfig = pageCollectionConfig;
    this.pathResolver = new PathResolver();
    this.routes = commonContainer.getAppRoutes();
    this.dynamicRoutes = {};
  }
  async getRoutes(locale) {
    let uri = `/${this.pageCollectionConfig.name}?${getQueryParams(["limit", "populate"])}`;
    if (locale)
      uri = `/${uri}&${getQueryParams(["locale", "limit", "populate"], locale)}`;
    const dataItems = await this.requestService.get(uri);
    let routes = [];
    this.routes = routes = [];
    const dynamicPageRoute = {};
    for (let i = 0; i < dataItems.length; i++) {
      const item = dataItems[i];
      const dynamicPage = readProp(item, DYNAMIC_PROP_NAMES);
      if (dynamicPage) {
        const dynamicItems = await this.requestService.get(`/${SnakeCaseSanitizer(dynamicPage)}?${getQueryParams(["limit", "populate"])}`);
        const seoItems = await this.requestService.get(`/${SnakeCaseSanitizer(dynamicPage)}?${getQueryParams(["limit", "seoPopulate"])}`);
        defaultContainer.cacheDynamicPageCollection(dynamicPage, dynamicItems);
        for (let j = 0; j < dynamicItems.length; j++) {
          const dynamicItem = dynamicItems[j];
          const seoItem = seoItems[j];
          let compareUrl = readProp(seoItem, URL_PROPS);
          let url = readProp(dynamicItem, URL_PROPS);
          if (compareUrl === url) {
            dynamicItem.seo = seoItem.seo;
            dynamicItem.masterPage = seoItem.masterPage;
          }
          if (url) {
            url = mergeUrl(readProp(item, URL_PROPS), url);
            const title = readProp(dynamicItem, TITLE_PROPS);
            dynamicPageRoute[url] = {
              url: readProp(item, URL_PROPS),
              data: { id: dynamicItem.id, title: title || "", content: readProp(dynamicItem, CONTENT_PROP_NAMES) || void 0, metaTags: readProp(dynamicItem, META_TAG_PROP_NAMES) || void 0, seo: readProp(dynamicItem, SEO_PROP_NAMES) || void 0 },
              referenceData: dynamicItem,
              collectionName: dynamicPage
            };
            const path2 = getUrl(url);
            if (routes.filter((t) => t.path === path2).length === 0) {
              this.addRoute({
                name: title,
                path: path2
              });
            }
          }
        }
      } else {
        this.addRoute({
          name: readProp(item, TITLE_PROPS),
          path: readProp(item, URL_PROPS)
        });
      }
    }
    return { routes, dynamicPageRoute };
  }
  addRoute(routeItem, isPage = false) {
    if (this.routes.filter((t) => t.path === routeItem.path).length === 0)
      this.routes.push({
        name: (routeItem.name || routeItem.path).replace(REMOVE_SPECIAL_CHARACTERS, UNDERSCORE),
        path: routeItem.path,
        fPath: getUrl(routeItem.path).split("/").join(path.sep),
        isPage
      });
  }
  addRoutes(routes) {
    this.routes = routes;
  }
  addDynamicRoute(dynamicPath, staticPath) {
    if (dynamicPath.indexOf(":") !== -1)
      this.dynamicRoutes[dynamicPath] = staticPath;
  }
  async save() {
    await writeFileSync(this.pathResolver.commonPath.dynamicRoutesPath, dynamicRouteCodeTemplate(this.dynamicRoutes), true);
    await writeFileSync(this.pathResolver.routesJsonPath, this.routes);
  }
}

function getFilterQueryParams(filterJson, populate = "deep") {
  const version = commonContainer.getStrapiConfig().version;
  if (version === 4) {
    let jObject = {};
    Object.keys(filterJson).forEach((key) => {
      jObject[key] = {
        "$eq": filterJson[key]
      };
    });
    return getQueryString({ filters: jObject, populate });
  } else {
    return getQueryString(filterJson);
  }
}

function removeAppProps(jObject) {
  let igNoreAppKeys = ["queryParams", "collectionType"];
  let jsonObject = {};
  if (Array.isArray(jObject)) {
    let items = [];
    jObject.forEach((item) => items.push(removeAppProps(item)));
    return items;
  } else if (isObject$1(jObject)) {
    Object.keys(jObject).forEach((key) => {
      if (igNoreAppKeys.indexOf(key) === -1) {
        if (Array.isArray(jObject[key])) {
          let items = [];
          jObject[key].forEach((item) => {
            if (isObject$1(item))
              items.push(removeAppProps(item));
            else
              items.push(item);
          });
          jsonObject[key] = items;
        } else if (isObject$1(jObject[key])) {
          jsonObject[key] = removeAppProps(jObject[key]);
        } else
          jsonObject[key] = jObject[key];
      }
    });
  }
  return jsonObject;
}

function removeSpace(value) {
  return value ? value.replace(REMOVE_SPACE, "") : "";
}

function dataFieldSelector(data, fields) {
  var jObject = [];
  data.forEach((item) => {
    var itemObject = {};
    fields = !fields ? Object.keys(item) : fields;
    fields.forEach((t) => {
      if (Array.isArray(t)) {
        itemObject[toCamelCase(t[0])] = t[1](item[t[0]]) + "...";
      } else
        itemObject[toCamelCase(t)] = item[t];
    });
    jObject.push(itemObject);
  });
  return jObject;
}

function getComponentName(componentName) {
  return commonContainer.getStrapiConfig().componentNames ? commonContainer.getStrapiConfig().componentNames[componentName] : componentName;
}

function tagBuilder(data, tag) {
  let strapiConfig = commonContainer.getStrapiConfig();
  const imageCdn = strapiConfig.media.cdnUri;
  const siteUrl = strapiConfig.siteUrl;
  if (data.linkingData)
    tag.linkingData = data.linkingData;
  if (data.metaTags) {
    tag.metaTag = {};
    data.metaTags.forEach((meta) => {
      let typeName = meta.type.toLowerCase();
      if (!tag.metaTag[typeName])
        tag.metaTag[typeName] = {};
      tag.metaTag[typeName][meta.key] = meta.value;
    });
  }
  if (data.MetaTitle || data.title)
    tag.title = data.MetaTitle || data.title;
  if (data.description) {
    if (!tag.metaTag)
      tag.metaTag = { name: {} };
    if (!tag.metaTag.name)
      tag.metaTag.name = {};
    tag.metaTag["name"]["description"] = data.description;
  }
  if (data.MetaDescription)
    tag.MetaNameTags.push({ type: NAME, title: DESCRIPTION, content: data.MetaDescription || data.description });
  if (data.MetaKeywords || data.keywords)
    tag.MetaNameTags.push({ type: NAME, title: KEYWORDS, content: data.MetaKeywords || data.keywords });
  if (data.LinkTags)
    data.LinkTags.forEach((t) => {
      tag.canonical = siteUrl + t.Href;
    });
  if (data.MetaNameTag)
    data.MetaNameTag.forEach((t) => {
      if (t.Content && t.Name) {
        tag.MetaNameTags.push({ type: NAME, title: t.Name.Title, content: t.Content });
      }
    });
  if (data.CharSetTag && data.CharSetTag.CharSet)
    tag.MetaNameTags.push({ type: CHARSET, content: data.CharSetTag.CharSet.Title });
  if (data.MetaPropertyTag)
    data.MetaPropertyTag.forEach((t) => {
      if (t.Content && t.Property)
        tag.MetaPropertyTags.push({ type: PROPERTY, title: t.Property.Title, content: t.Content });
    });
  if (data.MetaNameImageTag)
    data.MetaNameImageTag.forEach((t) => {
      if (t.Content && t.Name)
        tag.MetaNameTags.push({ type: NAME, title: t.Name.Title, content: `${imageCdn}${t.Content.name}` });
    });
  if (data.MetaPropertyImageTag)
    data.MetaPropertyImageTag.forEach((t) => {
      if (t.Content && t.Property)
        tag.MetaNameTags.push({ type: PROPERTY, title: t.Property.Title, content: `${imageCdn}${t.Content.name}` });
    });
}

function getDynamicPageRecord(pageContent, tag, currentUrl) {
  let pageUrl = readProp(pageContent, URL_PROPS);
  pageUrl = pageUrl.replace(ASTERISK, BLANK);
  currentUrl = currentUrl.replace(pageUrl, BLANK);
  let result = defaultContainer.getDynamicPageCollection(pageContent.DynamicPage, (t) => readProp(t, URL_PROPS) === currentUrl);
  let item = result[0];
  if (item && (item[META_TAGS] || item[TAGS_SEO])) {
    tagBuilder(item, tag);
    delete item[META_TAGS];
    delete item[TAGS_SEO];
  }
  return result;
}

function getGenericSections(masterPage, genericCollection) {
  let collection = [];
  let pre = masterPage && masterPage.pre && Array.isArray(masterPage.pre) ? masterPage.pre : [];
  let post = masterPage && masterPage.post && Array.isArray(masterPage.post) ? masterPage.post : [];
  pre.forEach((item) => collection.push(item));
  if (genericCollection && Array.isArray(genericCollection))
    genericCollection.forEach((item) => collection.push(item));
  post.forEach((item) => collection.push(item));
  return collection;
}

function mergeSeoObject(objects) {
  let jObject = {};
  for (let i = objects.length; i > 1; i--) {
    let topObject = objects[i - 1];
    let bottomObject = objects[i - 2];
    jObject.title = topObject.title;
    jObject.description = topObject.description;
    if (!topObject.title && bottomObject.title && !jObject.title)
      jObject.title = bottomObject.title;
    else if (topObject.title)
      jObject.title = topObject.title;
    if (!topObject.description && bottomObject.description && !jObject.description)
      jObject.description = bottomObject.description;
    else if (topObject.description)
      jObject.description = topObject.description;
    if (!topObject.linkingData && bottomObject.linkingData && !jObject.linkingData)
      jObject.linkingData = bottomObject.linkingData;
    else if (topObject.linkingData)
      jObject.linkingData = topObject.linkingData;
    if (!jObject.sitemap)
      jObject.sitemap = {};
    if (!topObject.sitemap && (bottomObject.sitemap && bottomObject.sitemap.changeFrequency) && !jObject.sitemap.changeFrequency)
      jObject.sitemap.changeFrequency = bottomObject.sitemap.changeFrequency;
    else if (topObject.sitemap && topObject.sitemap.changeFrequency)
      jObject.sitemap.changeFrequency = topObject.sitemap.changeFrequency;
    if (!topObject.sitemap && (bottomObject.sitemap && bottomObject.sitemap.priority !== void 0) && jObject.sitemap.priority === void 0)
      jObject.sitemap.priority = bottomObject.sitemap.priority;
    else if (topObject.sitemap && topObject.sitemap.priority !== void 0)
      jObject.sitemap.priority = topObject.sitemap.priority;
    setMetaTags(topObject.metaTags, jObject);
    setMetaTags(bottomObject.metaTags, jObject);
    jObject.redirectRoutes = topObject.redirectRoutes;
  }
  return jObject;
}
function setMetaTags(metaTags, jObject) {
  if (metaTags) {
    if (!jObject.metaTags)
      jObject.metaTags = [];
    let metas = jObject.metaTags;
    metaTags.forEach((meta) => {
      let metaTag = metas.filter((t) => t.key === meta.key)[0];
      if (!metaTag)
        metas.push(meta);
    });
  }
}

function getValueByPath(valuePath, entity) {
  const splitText = valuePath.split(".");
  var text = void 0;
  splitText.forEach((t) => {
    if (!text)
      text = entity[t.replace("#", "")];
    else
      text = text[t];
  });
  return text;
}

function parseQueryString(queryString, queryObject) {
  const splitQueryString = queryString.split(new RegExp("{{(.*?)}}", "g"));
  splitQueryString.forEach((t) => {
    if (t.indexOf("=") === -1) {
      let value = getValueByPath(t, queryObject);
      queryString = queryString.replace(`{{${t}}}`, value);
    }
  });
  return queryString;
}

function getPagePrePostComponents(collection) {
  var result = [];
  if (collection) {
    commonContainer.getStrapiConfig();
    collection.forEach((item) => {
      let componentName = removeSpace(item[VUE_REFERENCE_CODE] || item[VUE_COMPONENT_NAME]);
      let splitComponentNames = componentName.split(",");
      componentName = getComponentName(splitComponentNames[0]);
      let mobileComponentName = getComponentName(splitComponentNames[1]);
      if (splitComponentNames.length === 1 && componentName)
        result.push([{}, componentName]);
      else if (splitComponentNames.length === 2 && componentName && mobileComponentName)
        result.push([{ mobileComponentName, clientComponentName: componentName }, componentName]);
    });
  }
  return result;
}

function qsStringify(filterJson) {
  return qs.stringify(filterJson, {
    encodeValuesOnly: true
  });
}

function runDataSanitizer(dataSanitizers, dataItem, url, componentName, parentComponentName) {
  if (dataSanitizers) {
    dataSanitizers.forEach((santizerConfig) => {
      if (santizerConfig.toPass && santizerConfig.toPass(url, componentName, parentComponentName))
        dataItem = santizerConfig.sanitizer(dataItem);
      else if (santizerConfig.toPass === void 0 && santizerConfig.sanitizer)
        dataItem = santizerConfig.sanitizer(dataItem);
    });
  }
  return dataItem;
}

function sourcePaginationByUrl(url, componentName, item) {
  const sourcePaginationByUrl2 = commonContainer.getStrapiConfig().optimization?.sourcePaginationByUrl;
  let isPass = false;
  if (sourcePaginationByUrl2) {
    if (sourcePaginationByUrl2.filter((t) => t.url === url && (t.components.length === 0 || t.components === void 0) || t.url === url && t.components.filter((x) => x === componentName).length > 0).length > 0 && item[FIELD_DATA_TYPE_RESULT] !== DATA_CONTROL_GET_RECORD)
      isPass = true;
  }
  return isPass;
}

function parseObjectValue(jObject, item) {
  Object.keys(jObject).forEach((key) => {
    if (Array.isArray(jObject[key])) {
      for (let i = 0; i < jObject[key].length; i++)
        jObject[key][i] = isObject(jObject[key][i]) ? parseObjectValue(jObject[key][i], item) : parseValue(jObject[key][i], item);
    } else if (isObject(jObject[key])) {
      jObject[key] = parseObjectValue(jObject[key], item);
    } else {
      jObject[key] = parseValue(jObject[key], item);
      if (jObject[key] && typeof jObject[key] === "string")
        jObject[key] = jObject[key].replace(/"/g, "'");
    }
  });
  return jObject;
}
function parseValue(value, item) {
  if (EXTRACT_CURLY_BRACKETS_STRING.test(value) && value && item) {
    let matches = value.match(EXTRACT_CURLY_BRACKETS_STRING);
    matches.forEach((key) => {
      let func = new Function(...["t"], `return t.${key.replace(REMOVE_CURLY_BRACKETS, BLANK).replace(/[.]/g, "?.")};`);
      var parsedValue = func(item);
      value = value.replace(key, parsedValue);
    });
  }
  return value;
}

function getChecksum(text) {
  return crypto.createHash("md5").update(text).digest("hex");
}

class CollectionIndexer {
  constructor() {
    this.pagination = commonContainer.getStrapiConfig().pagination;
    this.pathResolver = new PathResolver();
  }
  async paginate(source, collectionName, filterString, pagination) {
    let index = 1;
    const filterKey = `${collectionName}-${filterString}`.toLowerCase();
    let folderKey = getChecksum(filterKey);
    if (filterString && !defaultContainer.filterCollectionState[filterKey] || !filterString && !defaultContainer.collectionState[collectionName]) {
      let totalCount = source.length;
      do {
        const pageSize = pagination ? source.length : source.length > this.pagination.pageSize ? this.pagination.pageSize : source.length;
        const sourceItems = source.splice(0, pageSize);
        let filePath = `${this.pathResolver.getCollectionPayloadPath(collectionName)}/${index}.json`;
        if (filterString)
          filePath = `${this.pathResolver.getFilterCollectionPayloadPath(folderKey)}/${index}.json`;
        else
          defaultContainer.collectionState[collectionName] = true;
        await writeFileSync(filePath, { items: sourceItems, totalCount });
        index++;
      } while (source.length > 0);
    }
    if (filterString) {
      if (!defaultContainer.filterCollectionState[filterKey])
        defaultContainer.filterCollectionState[filterKey] = folderKey;
      else
        folderKey = defaultContainer.filterCollectionState[filterKey];
    }
    return filterString ? `filter-collections/${folderKey}` : `collections/${collectionName}`;
  }
}

function jsonToString(jObject) {
  var queryString = "";
  Object.keys(jObject).forEach((t, i) => {
    if (i > 0)
      queryString += AND_OPERATOR;
    queryString += t + EQUALTO + jObject[t];
  });
  return queryString;
}

function converQueryToJsonObject(queryObject, entity) {
  var query = {};
  if (queryObject && queryObject.query && !queryObject.query.queryString) {
    Object.keys(queryObject.query).forEach((key) => {
      let keyValue = queryObject.query[key];
      if (keyValue.startsWith("#")) {
        keyValue = getValueByPath(keyValue, entity);
      }
      query[key] = keyValue;
    });
  }
  return query;
}

async function dataRequest(queryObject, entity) {
  const entityQueryParams = commonContainer.tezConfig?.payload?.entityQueryParams;
  const strapiEntity = SnakeCaseSanitizer(queryObject.entity);
  const requestService = new RequestService();
  if (entityQueryParams && entityQueryParams[strapiEntity.trim()]) {
    if (queryObject && !queryObject.query)
      queryObject.query = {};
    Object.keys(entityQueryParams[strapiEntity.trim()]).forEach((key) => queryObject.query[key] = entityQueryParams[strapiEntity.trim()][key]);
  }
  let url = `/${strapiEntity}`;
  if (queryObject && queryObject.query && queryObject.query.queryString)
    url = `${url}/?${queryObject.query.queryString}`;
  else {
    queryObject.query.queryString = jsonToString(converQueryToJsonObject(queryObject, entity));
    url = `${url}/?${queryObject.query.queryString}&${getQueryParams(["limit", "populate"])}`;
  }
  return await requestService.get(url);
}

async function DataResolver(pageContent, url) {
  const moduleOptions = commonContainer.getStrapiConfig();
  const collectionQuery = moduleOptions.collectionQuery;
  if (collectionQuery && collectionQuery[pageContent.Type]) {
    const result = await dataRequest(collectionQuery[pageContent.Type], pageContent);
    if (!pageContent.GenericSection)
      pageContent.GenericSection = [];
    result.forEach((item) => {
      if (item.MetaTags)
        pageContent.GenericSection.push({ [FIELD_COMPONENT_TYPE_NAME]: META_TAGS_COMPONENT_NAME, ...item.MetaTags });
      if (item.SEO)
        pageContent.GenericSection.push({ [FIELD_COMPONENT_TYPE_NAME]: META_TAGS_SEO_COMPONENT_NAME, ...item.SEO });
      item = runDataSanitizer(moduleOptions.payload.page.dataSanitizers, item, url, removeSpace(item[VUE_REFERENCE_CODE] || item[VUE_COMPONENT_NAME]));
      pageContent.GenericSection.push(item);
    });
  }
  return pageContent;
}

function getSitemapObject(pageObject, url, updated) {
  var jObject = void 0;
  const changeFrequency = readProp(pageObject, CHANGE_FREQUENCY);
  const priority = readProp(pageObject, PRIORITY);
  if (updated && changeFrequency && priority !== void 0) {
    var dt = new Date(updated);
    var date = dt.getFullYear() + "-" + ("0" + (dt.getMonth() + 1)).slice(-2) + "-" + ("0" + dt.getDate()).slice(-2);
    jObject = { loc: url, lastModified: date, changeFrequency, priority: priority == 1 ? "1.0" : priority };
  }
  return jObject;
}

async function parseStrapiData(pageContent, url, dynamicData, referenceData) {
  const collectionIndexer = new CollectionIndexer();
  const moduleOptions = commonContainer.getStrapiConfig();
  let genericSection = [];
  pageContent = await DataResolver(pageContent, url);
  if (pageContent)
    genericSection = getGenericSections(pageContent.masterPage, readProp(pageContent, COMPONENT_DATA_PROPS));
  let parseObjectItem = { ...pageContent, ...{ referencePageData: referenceData, genericCollections: genericSection } };
  const Tag = {
    title: "",
    canonical: "",
    MetaPropertyTags: [],
    MetaNameTags: [],
    PageSchema: ""
  };
  let components = [];
  for (let i = 0; i < genericSection.length; i++) {
    let item = genericSection[i];
    item = referenceData && item.referenceCollection === "Data" ? referenceData : item;
    let componentName = removeSpace(readProp(item, VUE_COMPONENT_NAME_PROPS));
    item = runDataSanitizer(commonContainer.tezConfig.payload?.page?.dataSanitizers, item, url, componentName);
    componentName = removeSpace(readProp(item, VUE_COMPONENT_NAME_PROPS));
    item.dynamic = dynamicData;
    if (getComponentName(componentName)) {
      let collectionType = readProp(item, COLLECTION_TYPE_PROPS);
      if (collectionType && moduleOptions.version > 3 || (item[FIELD_COMPONENT_TYPE_NAME] === FIELD_COMPONENT_NAME_GET_ALL_DATA || item[FIELD_COMPONENT_TYPE_NAME] === FIELD_COMPONENT_NAME_GET_DATA_FIELD_VALUE || item[FIELD_DATA_TYPE_RESULT] === DATA_CONTROL_ALL || item[FIELD_DATA_TYPE_RESULT] === DATA_CONTROL_FILTER || item[FIELD_DATA_TYPE_RESULT] === DATA_CONTROL_GET_RECORD) && moduleOptions.componentDataFieldSelectors[getComponentName(componentName)]) {
        let query = {};
        if (item[FIELD_DATA_TYPE_RESULT] === DATA_CONTROL_FILTER || item[FIELD_COMPONENT_TYPE_NAME] === FIELD_COMPONENT_NAME_GET_DATA_FIELD_VALUE) {
          if (item.Field)
            query[item.Field] = item.Value;
          else if (item.FilterQueryString)
            query.queryString = parseQueryString(item.FilterQueryString, item);
        } else if (item.queryParams)
          query.queryString = `${qsStringify(parseObjectValue(item.queryParams, parseObjectItem))}&${getQueryParams(["limit", "populate"])}`;
        const queryResult = item[FIELD_DATA_TYPE_RESULT] === DATA_CONTROL_GET_RECORD ? getDynamicPageRecord(pageContent, Tag, url) : await dataRequest({ entity: collectionType, query }, item);
        queryResult.forEach((dataItem, index) => {
          queryResult[index] = runDataSanitizer(commonContainer.tezConfig?.payload?.page?.dataSanitizers, dataItem, url, removeSpace(readProp(dataItem, VUE_COMPONENT_NAME_PROPS)), componentName);
        });
        const result = dataFieldSelector(queryResult, moduleOptions.componentDataFieldSelectors[getComponentName(componentName)]);
        if (moduleOptions.optimization.sourcePagination && item[FIELD_DATA_TYPE_RESULT] !== DATA_CONTROL_GET_RECORD || sourcePaginationByUrl(url, getComponentName(componentName), item))
          item.dynamicSourcePath = await collectionIndexer.paginate(result, collectionType.toLowerCase(), query.queryString, item.pagination);
        else
          item.dynamicResult = result;
      }
      delete item.dynamic;
      delete item.seo;
      delete item.masterPage;
      components.push({
        id: defaultContainer.getUniqueId(),
        name: getComponentName(componentName),
        data: removeAppProps(item)
      });
    } else if (item[FIELD_DATA_TYPE_RESULT] === META_TAGS || item[FIELD_DATA_TYPE_RESULT] === TAGS_SEO || item[FIELD_COMPONENT_TYPE_NAME] === META_TAGS_COMPONENT_NAME || item[FIELD_COMPONENT_TYPE_NAME] === META_TAGS_SEO_COMPONENT_NAME) {
      tagBuilder(item, Tag);
    }
  }
  let seo = {};
  if (pageContent && pageContent.masterPage)
    seo = mergeSeoObject([pageContent.masterPage.seo || {}, pageContent.seo || {}]);
  else if (pageContent.seo)
    seo = mergeSeoObject([{}, pageContent.seo || {}]);
  if (dynamicData && dynamicData.metaTags)
    tagBuilder(dynamicData.metaTags, Tag);
  if (dynamicData && dynamicData.seo)
    if (moduleOptions.version > 3) {
      seo = mergeSeoObject([seo, dynamicData.seo || {}]);
      tagBuilder(seo, Tag);
    } else
      tagBuilder(dynamicData.seo, Tag);
  else
    tagBuilder(seo, Tag);
  if (!Tag.canonical)
    Tag.canonical = moduleOptions.siteUrl + getUrl(url);
  let removeIndex = [];
  components.forEach((component, index) => {
    let componentReferencePath = readProp(component.data, COMPONENT_REFERENCE_PATH);
    if (componentReferencePath) {
      let componentNames = componentReferencePath.split(".");
      componentNames.forEach((t) => {
        let componentName = getComponentName(t);
        let referenceComponent = components.filter((x) => x.name === componentName)[0];
        if (referenceComponent && referenceComponent.data) {
          if (!referenceComponent.data[component.name])
            referenceComponent.data[component.name] = {};
          referenceComponent.data[component.name] = component;
          removeIndex.push(component);
        }
      });
    }
  });
  removeIndex.forEach((t) => {
    let indexOf = components.indexOf(t);
    if (indexOf !== -1)
      components.splice(indexOf, 1);
  });
  if (moduleOptions.version > 3) {
    delete Tag.MetaPropertyTags;
    delete Tag.MetaNameTags;
  }
  return {
    masterPageName: pageContent && pageContent.masterPage && pageContent.masterPage.title ? pageContent.masterPage.title : "",
    components,
    url: getUrl(url),
    seo: parseObjectValue(Tag, parseObjectItem),
    redirectRoutes: seo ? seo.redirectRoutes : [],
    sitemap: getSitemapObject(seo.sitemap || pageContent, Tag.canonical, readProp(pageContent, UPDATED_AT)),
    sections: getPagePrePostComponents(readProp(pageContent, PRE_SECTION_PROPS)),
    footerSections: getPagePrePostComponents(readProp(pageContent, POST_SECTION_PROPS))
  };
}

class PageSlot {
  constructor() {
    this.slots = {};
  }
  getSlot(slotName) {
    return !this.slots[slotName || "default"] ? this.slots[slotName || "default"] = [] : this.slots[slotName || "default"];
  }
}

function replaceSpace(text) {
  return text.replace(/ /g, "-").toLowerCase();
}

class MasterPageCollection {
  constructor(globWriter) {
    this.globWriter = globWriter;
    this.isGenerated = false;
    this.request = new RequestService();
    this.pathResolver = new PathResolver();
    this.pageSlot = new PageSlot();
  }
  async setMasterPageInfo(pageData, referenceData) {
    const item = referenceData && referenceData.masterPage && Object.keys(referenceData.masterPage).length > 0 ? referenceData : pageData;
    if (!this.isGenerated && item.masterPage && item.masterPage.title) {
      let masterPage = await parseStrapiData(item.masterPage, void 0, void 0, void 0);
      const directoryPath = path.join(this.pathResolver.payloadPath, "master-pages");
      createPath(directoryPath);
      let index = 0;
      for (let component of masterPage.components) {
        if (component.data.slotName) {
          let componentId = `${index}-${component.name}`;
          let slot = this.pageSlot.getSlot(component.data.slotName);
          delete component.data.slotName;
          slot.push([component.data, componentId]);
          index++;
          this.globWriter.addComponent(component.name);
        }
      }
      let filePath = path.join(directoryPath, `${replaceSpace(item.masterPage.title)}.json`);
      this.globWriter.addLayout(item.masterPage.layoutName);
      await writeFileSync$1(filePath, { layoutName: item.masterPage.layoutName, slots: this.pageSlot.slots });
      this.isGenerated = true;
    }
    return item.masterPage;
  }
}

async function writeImage(imagePath) {
  const pathResolver = new CommonPathResolver();
  return new Promise(async (resolve, reject) => {
    try {
      let filePath = `${pathResolver.imageFolderPath}${imagePath}`;
      if (!pathResolver.pathExists(filePath)) {
        let fileExtension = filePath.split(".").pop();
        const response = await getImage(imagePath);
        const writer = fs.createWriteStream(filePath);
        writer.on("error", (err) => {
          console.log("downloadFileFn writer error called \u2192 ", err);
          error = err;
          writer.close();
          resolve(true);
        });
        writer.on("close", () => {
          if (!error) {
            if (commonContainer.tezConfig.image?.enableWebPConversion) {
            } else
              resolve(true);
          }
        });
        response.data.pipe(writer);
        let error = null;
      } else {
        resolve(true);
      }
    } catch (err) {
      console.log(err);
      reject(err);
    }
  });
}
async function getImage(imageUrl) {
  return await axios({
    method: "get",
    url: `${commonContainer.getStrapiConfig().apiUri}${imageUrl}`,
    responseType: "stream"
  });
}

function isPageComponent(name) {
  return name.indexOf("pages/") !== -1;
}

class BaseGenerator {
  constructor(redirectRoute, sitemap, globWriter, pageRoute) {
    this.redirectRoute = redirectRoute;
    this.sitemap = sitemap;
    this.globWriter = globWriter;
    this.pageRoute = pageRoute;
    const { payload } = commonContainer.tezConfig;
    this.pathResolver = new PathResolver();
    this.payload = payload;
  }
  async generatePage(page) {
    const url = getUrl(page.url);
    const directoryPath = path.join(this.pathResolver.payloadPath, url);
    let pageSlot = new PageSlot();
    let index = 0;
    for (let j = 0; j < page.components.length; j++) {
      let component = page.components[j];
      let componentId = `${j}-${component.name}`;
      let slot = pageSlot.getSlot(component.slotName);
      let isExits = isPageComponent(component.name);
      if (!isExits)
        isExits = this.globWriter.addComponent(component.name);
      else
        this.globWriter.addPage(component.name);
      if (isExits) {
        const filePath2 = path.join(directoryPath, componentId + ".json");
        slot.push(this.payload.page.maxPreLoadComponent > index ? [component.data || {}, componentId] : [componentId]);
        if (this.payload.page.maxPreLoadComponent <= j)
          await writeFileSync$1(filePath2, component.data);
        index++;
      }
    }
    let filePath = path.join(directoryPath, "tags.json");
    await writeFileSync$1(filePath, cleanObject(page.seo || {}));
    const fileName = url.split("/");
    filePath = path.join(directoryPath, fileName[fileName.length - 1] + ".json");
    let pageJson = { slots: pageSlot.slots };
    if (page.masterPageName)
      pageJson["masterPage"] = replaceSpace(page.masterPageName);
    await writeFileSync$1(filePath, pageJson);
    if (page.sitemap)
      this.sitemap.add({ sitemap: { ...page.sitemap, ...{ loc: `${commonContainer.getStrapiConfig().siteUrl}${page.url}` } } });
    this.redirectRoute.add(page);
  }
  async generateRoute(page) {
    let url = getUrl(page.url);
    console.log(url);
    this.pageRoute.addRoute({ path: page.url }, true);
    const directoryPath = path.join(this.pathResolver.payloadPath, url);
    createPath(directoryPath);
    await this.generatePage(page);
  }
}

class PayloadGenerator extends BaseGenerator {
  constructor(requestService, redirectRoute, sitemap, globWriter) {
    super(redirectRoute, sitemap, globWriter);
    this.requestService = requestService;
    const { pageCollectionConfig } = commonContainer.getStrapiConfig();
    this.pageCollectionConfig = pageCollectionConfig;
  }
  async generate(route, dynamicPageRoute) {
    this.masterPageCollection = new MasterPageCollection(this.globWriter);
    let url = getUrl(route.path);
    let baseUrl = url;
    let dynamicData = void 0;
    let referenceData = void 0;
    let collectionName = void 0;
    if (dynamicPageRoute[url]) {
      dynamicData = dynamicPageRoute[url].data;
      baseUrl = url;
      referenceData = dynamicPageRoute[url].referenceData;
      collectionName = dynamicPageRoute[url].collectionName;
      url = dynamicPageRoute[url].url;
    }
    const directoryPath = path.join(this.pathResolver.payloadPath, baseUrl);
    const isNotExits = createPath(directoryPath);
    if (isNotExits) {
      console.log(baseUrl);
      let filterQuery = { [this.pageCollectionConfig.fieldName.uri]: getUrl(url) };
      if (collectionName)
        filterQuery["ReferencePages"] = collectionName;
      const result = await this.requestService.get(`/${this.pageCollectionConfig.name}?${getFilterQueryParams(filterQuery)}`);
      let item = result && result[0] ? result[0] : {};
      item.masterPage = await this.masterPageCollection.setMasterPageInfo(item, referenceData);
      const page = await parseStrapiData(item, baseUrl, dynamicData, referenceData);
      if (page) {
        await this.generatePage(page);
      }
      await this.writeImages();
      return page;
    }
    return null;
  }
  async writeImages() {
    for (const uri of defaultContainer.writeImageUris)
      await writeImage(uri);
  }
}

class Sitemap {
  constructor() {
    this.sitemap = {};
    this.pathResolver = new PathResolver();
    this.sitemap = readFileSync(this.pathResolver.sitemapJsonPath) || {};
  }
  add(page) {
    if (page && page.sitemap && Object.keys(page.sitemap).length > 0)
      this.sitemap[page.sitemap.loc] = page.sitemap;
  }
  save() {
    const notMapped = [];
    let keys = Object.keys(this.sitemap);
    if (keys.length > 0) {
      let sitemapUris = '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';
      Object.keys(this.sitemap).forEach((urlNode) => {
        sitemapUris += this.xmlElement(this.sitemap[urlNode]);
      });
      sitemapUris += `</urlset>`;
      writeFileSync(this.pathResolver.sitemapXmlPath, sitemapUris, true);
      writeFileSync(this.pathResolver.sitemapNotMappedJsonPath, notMapped);
      writeFileSync(this.pathResolver.sitemapJsonPath, this.sitemap);
    }
  }
  xmlElement(sitemap) {
    let xElement = new Array();
    xElement.push(`<url>
`);
    xElement.push(`<loc>${sitemap.loc}</loc>
`);
    if (sitemap.lastModified)
      xElement.push(`<lastmod>${sitemap.lastModified}</lastmod>
`);
    if (sitemap.changeFrequency)
      xElement.push(`<changefreq>${sitemap.changeFrequency}</changefreq>
`);
    if (sitemap.priority)
      xElement.push(`<priority>${sitemap.priority}</priority>
`);
    xElement.push(`</url>
`);
    return xElement.join("");
  }
}

class RobotTxtGenerator {
  constructor() {
    this.request = new RequestService();
    this.pathResolver = new PathResolver();
    this.robotsConfig = commonContainer.getStrapiConfig().robots;
  }
  async generate() {
    if (this.robotsConfig && !commonContainer.getStrapiConfig().customPayloadGenerator) {
      const result = await this.request.get(`/robots?${getFilterQueryParams({ Environment: this.robotsConfig.environmentName })}`);
      const item = result && result[0] ? result[0] : void 0;
      if (item)
        this.save(item.rules);
    } else if (!commonContainer.tezConfig.robots || commonContainer.tezConfig.robots[commonContainer.tezConfig.envName]) {
      let text = commonContainer.tezConfig.robots && commonContainer.tezConfig.robots[commonContainer.tezConfig.envName] ? commonContainer.tezConfig.robots[commonContainer.tezConfig.envName] : `User-agent: *
Disallow: /`;
      this.save(text);
    }
  }
  save(text) {
    if (this.robotsConfig && !commonContainer.getStrapiConfig().customPayloadGenerator)
      writeFileSync(this.pathResolver.robotsTxtPath, text, true);
  }
}

class RedirectRoute {
  constructor() {
    this.routes = [];
    this.pathResolver = new PathResolver();
    this.routes = readFileSync(this.pathResolver.redirectRoutesJsonPath) || [];
  }
  add(page) {
    if (page && page.redirectRoutes && Array.isArray(page.redirectRoutes))
      page.redirectRoutes.forEach((item) => {
        if (item.from && item.statusCode)
          this.routes.push({ ...item, ...{ to: page.url } });
      });
  }
  save() {
    writeFileSync(this.pathResolver.redirectRoutesJsonPath, this.routes);
  }
}

class CustomPagePayload extends BaseGenerator {
  constructor(redirectRoute, sitemap, pageRoute) {
    super(redirectRoute, sitemap);
    this.pageRoute = pageRoute;
    this.requestService = new RequestService();
  }
  async generate(routePath) {
    const pages = commonContainer.tezConfig.pages;
    for (let page of pages) {
      let url = getUrl(page.url);
      console.log(url);
      this.pageRoute.addRoute({ path: page.url });
      const directoryPath = path.join(this.pathResolver.payloadPath, url);
      const isNotExits = createPath(directoryPath);
      if (isNotExits) {
        for (const component of page.components) {
          let payload = await this.getPayload(component, url);
          component.data = payload;
        }
      }
      await this.generatePage(page);
    }
    this.pageRoute.save();
  }
  async getPayload(component, url) {
    return new Promise(async (resolve, reject) => {
      let payloadData = component.data;
      switch (typeof component.data) {
        case "string":
          payloadData = await this.requestService.payloadRequest(component.data);
          break;
        case "function":
          let result = component.data(url);
          if (result instanceof Promise) {
            payloadData = await result;
          } else
            payloadData = result;
          break;
      }
      if (payloadData === void 0)
        payloadData = {};
      resolve(payloadData);
    });
  }
}

const FIRE_BASE_CONFIG = {
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*"
    ],
    "trailingSlash": false,
    "headers": [
      {
        "source": "/**",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-cache, no-store, must-revalidate"
          }
        ]
      },
      {
        "source": "**/*.@(js|eot|otf|ttf|ttc|woff|font|css)",
        "headers": [
          {
            "key": "cache-control",
            "value": "max-age=86400"
          }
        ]
      },
      {
        "source": "**",
        "headers": [
          {
            "key": "X-Content-Type-Options",
            "value": "nosniff"
          },
          {
            "key": "X-Frame-Options",
            "value": "SAMEORIGIN"
          },
          {
            "key": "X-Permitted-Cross-Domain-Policies",
            "value": "none"
          },
          {
            "key": "Referrer-Policy",
            "value": "no-referrer"
          },
          {
            "key": "Strict-Transport-Security",
            "value": "max-age=15552000; includeSubDomains"
          },
          {
            "key": "X-Download-Options",
            "value": "noopen"
          },
          {
            "key": "X-UA-Compatible",
            "value": "ie=edge"
          },
          {
            "key": "X-XSS-Protection",
            "value": "1; mode=block"
          }
        ]
      }
    ],
    "redirects": [],
    "rewrites": []
  }
};

class DeploymentPathResolver {
  constructor() {
    this.commonPath = new CommonPathResolver();
  }
  get firebaseConfigPath() {
    return getPath([this.commonPath.rootPath, "firebase.json"]);
  }
  get redirectRoutesJson() {
    return this.commonPath.redirectRoutesJsonPath;
  }
}

class BaseDeployment {
  constructor() {
    this.pathResolver = new DeploymentPathResolver();
  }
}

class FirebaseDomain extends BaseDeployment {
  constructor() {
    super();
  }
  create(firebase, redirectRoutes) {
    let firebaseConfig = firebase;
    if (isObject$1(firebase)) {
      firebaseConfig = firebase;
    } else
      firebaseConfig = FIRE_BASE_CONFIG;
    this.addRedirects(firebaseConfig, redirectRoutes);
    writeFileSync$1(this.pathResolver.firebaseConfigPath, firebaseConfig);
  }
  addRedirects(firebase, redirectRoutes) {
    if (firebase.hosting && !firebase.hosting.redirects)
      firebase.hosting.redirects = [];
    if (redirectRoutes.length > 0 && Array.isArray(firebase.hosting.redirects)) {
      redirectRoutes.forEach((route) => {
        firebase.hosting.redirects.push({
          "source": route.from,
          "destination": route.to,
          "type": route.statusCode
        });
      });
    }
  }
}

class DeploymentDomain {
  constructor() {
    this.redirectRoutes = new Array();
    this.firebase = new FirebaseDomain();
    this.commonPath = new CommonPathResolver();
    this.redirectRoutes = readFileSync(this.commonPath.redirectRoutesJsonPath);
  }
  generate() {
    if (commonContainer.tezConfig.deployment) {
      if (commonContainer.tezConfig.deployment.firebase)
        this.firebase.create(commonContainer.tezConfig.deployment.firebase, this.redirectRoutes);
    }
  }
}

class GlobWriter {
  constructor() {
    this.pathResolver = new PathResolver();
    const globJson = readFileSync(this.pathResolver.globJsonPath) || { components: [], layouts: [], pages: [] };
    this.components = globJson.components;
    this.layouts = globJson.layouts;
    this.pages = globJson.pages || [];
  }
  async setLayoutComponents() {
    let components = await this.pathResolver.commonPath.getFiles("layouts", "vue");
    components.forEach((component) => this.addLayout(component));
  }
  addComponent(name) {
    const isPathExits = this.pathResolver.pathExists(getPath([this.pathResolver.componentsPath, `${name}.vue`], false));
    if (this.components.filter((t) => t === name).length === 0 && isPathExits)
      this.components.push(name);
    return isPathExits;
  }
  addLayout(name) {
    if (this.layouts.filter((t) => t === name).length === 0)
      this.layouts.push(name);
  }
  addPage(name) {
    if (this.pages.filter((t) => t === name).length === 0)
      this.pages.push(name);
  }
  write() {
    writeFileSync$1(this.pathResolver.globJsonPath, { components: this.components, layouts: this.layouts, pages: this.pages });
  }
}

class PayloadModuleRunner extends BaseGenerator {
  constructor(redirectRoute, sitemap, pageRoute, globWriter) {
    super(redirectRoute, sitemap, globWriter, pageRoute);
  }
  async runPayload(config) {
    const modules = commonContainer.tezConfig.modules;
    if (modules && Array.isArray(modules)) {
      for (const tezModule of modules) {
        if (tezModule.payload) {
          const payloadRoutes = await tezModule.payload(config);
          if (payloadRoutes) {
            for (const [routePath, payload] of Object.entries(payloadRoutes)) {
              let url = routePath.replace(/:/g, "_");
              this.generateRoute({ ...payload, ...{ url } });
              this.pageRoute.addDynamicRoute(routePath, url);
            }
          }
        }
      }
    }
  }
}

class PageCollection {
  constructor() {
    this.requestService = new RequestService();
    this.internationalizationService = new InternationalizationService(this.requestService);
    this.pageRoute = new PageRoute(this.requestService);
    this.sitemap = new Sitemap();
    this.robotsGenerator = new RobotTxtGenerator();
    this.redirectRoute = new RedirectRoute();
    this.globWriter = new GlobWriter();
    this.payloadGenerator = new PayloadGenerator(this.requestService, this.redirectRoute, this.sitemap, this.globWriter);
    this.pathResolver = new PathResolver();
    this.commonPathResolver = new CommonPathResolver();
    this.customPagePayload = new CustomPagePayload(this.redirectRoute, this.sitemap, this.pageRoute);
    this.moduleRunner = new PayloadModuleRunner(this.redirectRoute, this.sitemap, this.pageRoute, this.globWriter);
  }
  async generate(routePath) {
    await this.globWriter.setLayoutComponents();
    let config = {
      routePath,
      redirectRoute: this.redirectRoute,
      sitemap: this.sitemap,
      globWriter: this.globWriter,
      pathResolver: this.pathResolver,
      pageRoute: this.pageRoute
    };
    if (commonContainer.tezConfig.strapi) {
      if (commonContainer.tezConfig.strapi.customPayloadGenerator)
        await commonContainer.tezConfig.strapi.customPayloadGenerator(config);
      else
        await this.generateStrapiPayload(routePath);
    }
    if (commonContainer.tezConfig.pages)
      await this.customPagePayload.generate(routePath);
    await this.moduleRunner.runPayload(config);
    this.pageRoute.save();
    if (commonContainer.tezConfig.generate.sitemap)
      this.sitemap.save();
    if (commonContainer.tezConfig.generate.robots)
      await this.robotsGenerator.generate();
    this.redirectRoute.save();
    this.globWriter.write();
    if (commonContainer.buildOptions.commandName === "build") {
      this.deployment = new DeploymentDomain();
      this.deployment.generate();
    }
  }
  async generateStrapiPayload(routePath) {
    await this.requestService.login();
    const locales = await this.internationalizationService.getLocales();
    for (let j = 0; j < locales.length; j++) {
      const pageRouteResponse = await this.pageRoute.getRoutes(locales.length === 1 ? "" : locales[j]);
      for (let i = 0; i < pageRouteResponse.routes.length; i++) {
        const route = pageRouteResponse.routes[i];
        if (routePath === route.path || !routePath) {
          let deleteRouteFolder = routePath === route.path;
          if (deleteRouteFolder) {
            this.deletePayloadItem(`${this.pathResolver.payloadPath}${getUrl(routePath)}`);
            defaultContainer.clearState();
          }
          await this.payloadGenerator.generate(route, pageRouteResponse.dynamicPageRoute);
          if (deleteRouteFolder)
            break;
        }
      }
    }
  }
  deletePayloadItem(routePath) {
    this.commonPathResolver.removeDirSync(routePath);
  }
}

function getFriendlyComponentName(name) {
  for (var replacer of ["pages/", "components/", "layouts/"])
    name = name.replace(replacer, BLANK);
  return name.replace(REMOVE_SPECIAL_CHARACTERS, UNDERSCORE);
}

export { GlobWriter, PageCollection, getFriendlyComponentName };
